### COs Pro(코딩전문가자격시험) 1급 자바 ###


 # 이클립스 단축키
- ctrl + +,-   : 폰트 크기
- ctrl + D     : 한 줄 삭제
- ctrl + /     : 주석 토글
- ctrl + space : 자동 완성
- ctrl + i     : 자동 들여쓰기
- 이클립스 에러난 클래스 위에서 ctrl + shift + m(o) 자동으로 import됨
- sysout -> ctrl + space  : System.out.println()

 # 기본 자료형 int 크기와 범위
- int : 4byte, -2,147,483,648 ~ 2,147,483,647
- 자바 기본 정수 연산은 int

 # 배열 초기화
- 배열 초기화 : Arrays.fill(배열, 초기값);
- 배열 정렬(오름차순) : Arrays.sort(배열); / Arrays.sort(배열, 시작 인덱스, 끝 인덱스);
- 배열 정렬(내림차순) : Arrays.sort(배열, Collections.reverseOrder()); / Wrapper 타입만 가능

 # 오버라이딩
- Child c1 = new Child();
  c1.sing(); // 랩을 잘한다.

  Dad c2 = new Child();
  c2.sing(); // 랩을 잘한다.

  부모의 sing()을 호출하려면 자식의 메소드에서 super.sing() 호출해야 한다.

 # 상속, 구현 키워드
- 상속 : extends
- 구현 : implements

 # 삼항 연산자
- (조건식) ? 반환값1(true) : 반환값2(false);

 # String 클래스
- char charAt(int index) : 문자열에서 해당 인덱스 위치에 있는 문자 리턴
- boolean isEmpty()      : 문자열이 비어 있으면 true
- int length()           : 문자열의 길이 리턴
- char[] toCharArray()   : 문자열을 char 배열로 반환 // Arrays.toString()은 배열을 문자열로 반환
- String replace(char oldChar, char newChar) : oldChar를 newChar로 대체
- boolean startsWith(String prefix)          : 시작 문자열이 prefix와 동일하면 true
- boolean endsWith(String suffix)            : 끝 문자열이 suffix와 동일하면 true
- boolean equals(Object anObject)            : 문자열과 인수로 받은 문자열의 동일 여부를 리턴
- int indexOf(String str)      : 해당 문자열이 들어 있는 인덱스 번호 리턴
- static String valueOf(int i) : 값을 문자열로 변환하여 리턴
- String substring(int beginIndex, int endIndex) : 시작 인덱스에서 끝 인덱스 전까지 부분 문자를 잘라 리턴. 끝 인덱스 생략 가능
- String[] split(구분자) : 구분자를 기준으로 문자를 잘라 String[]에 순서대로 리턴

 # Math 클래스
- Math.random()      : 0.0이상 1.0미만의 임의의 실수값을 리턴
- Math.abs(값)       : 절대값을 리턴
- Math.max(값1, 값2) : 값1과 값2중 더 큰 값을 리턴
- Math.min(값1, 값2) : 값1과 값2중 더 작은 값을 리턴
- Math.ceil(값)      : 소수 부분을 올린 값을 리턴
- Math.floor(값)     : 소수 부분을 버린 값을 리턴
- Math.round(값)     : 소수 첫째 자리에서 반올림한 값을 리턴
- Math.sqrt(값)      : 제곱근 값을 리턴

 # Arrays 클래스
- Arrays.fill(배열명, 값) : 배열의 값 초기화
- Arrays.toString(배열명) : 배열의 항목 전체를 한 줄의 문자열로 변환하여 리턴
- int[] copyOf(int[] original, int newLength) : 배열에서 해당 길이를 갖는 새 배열로 복사해서 리턴
- int[] copyOfRange(int[] original, int from, int to) : 배열의 from에서 to 이전 인덱스까지 복사해서 리턴
- void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) - System 클래스
  => src배열의 srcPos인덱스부터 시작해서 총 length까지 복사(dest배열의 destPos 인덱스부터)
  => arraycopy는 dest 배열이 미리 존재해야 함
- Arrays.sort(배열명) : 배열을 오름차순으로 정렬
- boolean equals(int[] a, int[] b) : 두 배열의 내용을 비교해서 true/false 리턴
- Arrays.binarySearch(int[] a, int key) ; 배열에서 key를 찾아서 있으면 해당 인덱스 값 리턴(없으면 0보다 작은 수)
  => 주의 : 이진 탐색 알고리즘을 사용하므로 반드시 배열이 정렬되어 있어야 함

 # List<E>
- add(int index, Object element) : 지정된 index에 해당 element 추가
- get(int index) : 지정된 index의 객체 얻기
- set(int index) : 지정된 index의 객체 저장하기
- remove(int index) : 객체 삭제

 # Iterator
LinkedList<Integer> lnklist = new LinkedList<>();
Iterator<Integer> iter = lnklist.iterator();
Integer v1;
while(iter.hasnext()) {
    v1 = iter.next();
    if(v1==1) {
        iter.remove();
    }
}

 # 그리디(Greedy) 알고리즘
- 각 단계에서 최적의 값을 찾는 알고리즘
- 대부분 뛰어난 결과를 도출하지 못하지만 때때로 최적 해를 제시하는 경우도 있음
- 대표적 사례 : 거스름돈 문제, 배낭에 짐 넣기 문제

 # 문자(열) 연산
- 문자 : ASCII 코드값
- char c='A'
- c-'A' = 0
- char i = '3'
- i - 48 하지말고, i - '0' = 3

 # 이동
dx[], dy[] 쌍으로 구하고
현재위치 cx, cy를 구한다.
for문 돌면서 nx = cx + dx[i]
            ny = cy + dy[i]
이후 nx, ny가 조건에 맞는지 체크
실제 이동이라면 현재위치 옮기기, 이동가능여부 판단이면 count++;

 # 합이 K가 되는 세 숫자 고르기
- 브루트 포스 방식
  -> 세 개의 중첩 for 문을 사용하여 배열에 저장되어 있는 모든 수의 조합이 조건에 만족하는지 확인하며 답을 구함

- 투 포인터 방식
Arrays.sort(arr);
for(p=0; p<n-2; p++) {
    left = p+1;
    right = n-1;

    while(left<right) {
        sum = arr[p]+arr[left]+arr[right];
        if(sum < K) {
            left += 1;
        } else if(sum > K) {
            right -= 1;
        } else {
            answer += 1;
            left += 1;
            right -= 1;
        }
    }
}

 # 브루트 포스, 그리디, 분할 정복법, 동적 계획법
- 브루트 포스(Brute-Force)
  -> 모든 경우를 탐색
  -> 완전 탐색이 필요한 문제
  -> 시간이 많이 소요
  -> 예외 없는 정답
- 그리디Greedy)
  -> 큰 문제를 작은 문제로 나누어 해결
  -> 작은 문제의 최적을 선택하면 전체가 최적이 되는 문제
  -> 눈 앞의 이익만 고려. 최적의 결과를 보장할 수 없음
  -> 모든 방법을 고려하지 않지만 최적인 경우가 존재
  -> 큰 화폐 단위부터 거스름돈 주기
- 분할 정복법(Divide & Conquer)
  -> 큰 문제를 작은 문제로 나누어 해결
  -> 하위 문제가 상위와 종속되지 않는 문제
  -> 재귀호출 사용. 너무 작게 나누면 복잡해질 수 있음
  -> 큰 문제를 작게 나눠 효과적이나 재귀호출로 인한 시간 증가
  -> 이진 검색, 퀵 정렬
- 동적 계획법(Dynamic Programming)
 -. 메모이제이션(memoization)
  -> 큰 문제를 작은 문제로 나누어 해결
  -> 하위의 결과값이 상위의 결과에 영향을 주는 문제(종속)
  -> 하위 문제가 최적 부분 구조를 구성하고 동일한 하위 문제를 반복적으로 해결하여 결과를 저장하는 문제
  -> 재귀호출 방식이나 하위 문제 결과를 메모리에 저장한 후 재사용
  -> 최적해를 구함. 시간 감소, 공간 증가(브루트 포스에 비해)
  -> 최적화 문제에 적합 : 최적 경로 문제, 최소 비용 문제(최적화 문제 : 하나의 문제에 답이 여러 개인 경우의 문제)
 -. 타블레이션
  -> 큰 문제를 작은 문제로 나누어 해결
  -> 하위의 결과값이 상위의 결과에 영향을 주는 문제(종속)
  -> 하위 문제가 최적 부분 구조를 구성하고 동일한 하위 문제를 반복적으로 해결하여 결과를 저장하는 문제
  -> 재귀호출을 하지 않음. 첫 번째부터 모든 결과를 저장
  -> 최적해를 구함. 시간 감소, 공간 증가(브루트 포스에 비해)
  -> 최적화 문제에 적합 : 최적 경로 문제, 최소 비용 문제(최적화 문제 : 하나의 문제에 답이 여러 개인 경우의 문제)

 # 브루트 포스, 슬라이딩 윈도우, 투 포인터
- 브루트 포스(Brute-Force)
  -> 모든 경우를 탐색해야 할 때
  -> 중첩 반복문을 이용해 순회
- 슬라이딩 윈도우 방식(Sliding Window)
  -> 연속된 구간의 데이터에 대한 문제일 때
  -> 일정 구간을 정해서 이동시킴
  -> 이전합계 - 이전 윈도우 맨 앞의 수 + 다음 윈도우에 추가될 수
- 투 포인터(Two Pointer)
  -> 정렬 되어 있고, 중복된 값이 없을 때
  -> 포인터 두 개를 활용

=> 세 수의 합이 K의 배수가 되는 경우의 수 구하기 : 브루트 포스
=> 연속된 K개 수의 합의 최댓값 구하기 : 브루트 포스, 슬라이딩 윈도우
=> 세 수의 합이 K가 되는 수 구하기 : 브루트 포스, 투 포인터

 # 오버라이딩
class Dad {
    void sing() {
        System.out.println("노래를 잘한다");
    }
}
class Child extends Dad {
    void sing() {
        System.out.println("랩을 잘한다");
    }
    void callSuper() {
        super.sing();
    }
}

Child c1 = new Child();
c1.sing();      // 랩을 잘한다
c1.callSuper(); // 노래를 잘한다

Dad c2 = new Child();
c2.sing();      // 랩을 잘한다
c2.callSuper(); // error

 # 스택(Stack) 자료구조 - LIFO : 후입선출
- Boolean empty() : 스택이 비어 있는지 알려줌
- E peek()        : 삭제 없이 맨 앞(위)의 요소를 읽어옴
- E pop()         : 스택에서 맨 위(top)의 객체를 꺼내 반환(데이터 삭제)
- E push(E item)  : 마지막(top) 위(뒤)에 데이터 저장
- int search(Ojbect o) : 스택에서 주어진 객체 o를 찾아서 그 위치를 반환(없으면 -1, 시작 위치 1)

 # 큐(Queue) 자료구조 - FIFO : 선입선출, 인터페이스라 Queue<Integer> q = new LinkedList<Integer>();로 생성
- Boolean add(E e) : 지정된 객체를 큐에 추가(저장 공간 부족 시 IllegalStateException 발생)
- E element()      : 삭제 없이 요소를 읽어옴
- Boolean offer(E e) : 큐에 객체를 저장
- E peek()         : 삭제 없이 맨 앞(위)의 요소 읽어옴
- E poll()         : 큐에서 객체를 꺼내서 반환(큐에서 데이터 삭제)
- E remove()       : 큐에서 객체를 꺼내서 데이터 삭제


 ## 그래프 이론 ##
- 깊이 우선 탐색 : Depth First Search(DFS)
  -> 스택, 재귀로 구현
  -> 백트래킹에 유용
  -> 세로 방향에 있는 노드를 먼저 방문하는 방법

- 너비 우선 탐색 : Breadth First Search(BFS)
  -> 큐로 구현
  -> 그래프의 최단 경로를 구하는 문제에 유용
  -> 가로 방향에 있는 노드를 먼저 방문하는 방법


 # 합집합-찾기(union-find) 알고리즘
- 서로소 집합(disjoint-set) or 병합-찾기 집합(merge-find set)이라고도 함
- 서로소 집합인지를 판별하기 위한 알고리즘
- 어떤 두 노드를 선택했을 때 두 노드가 같은 그래프에 속하는 지 찾아내는 알고리즘
- 무방향 그래프에서 사이클 판별 시에 사용됨

 # 유클리드 호제법
a(큰수)   b(작은수)   r(a%b)
  72         27       18
  27    ↙   18   ↙   9
  18    ↙    9   ↙   0
         
           => 9가 최대공약수


 
 
 # 리터럴 타입 접미사
- long = 15789L;
- float = 3.14f;

 # 대입 연산자와 증감 연산자
- A += B : A에 B를 더한 값을 A에 할당
- A -= B : A에서 B를 뺀 값을 A에 할당
- A *= B : A에 B를 곱한 값을 A에 할당
- A /= B : A를 B로 나눈 값을 A에 할당
- A %= B : A를 B로 나눈 나머지를 A에 할당
- A++    : A를 1만큼 증가
- A--    : A를 1만큼 감소

 # 논리 연산자
- A && B : A와 B 모두 참이면 참(AND 연산)
- A || B : A와 B 중 하나라도 참이면 참(OR 연산)
- !A     : A가 참이면 거짓, A가 거짓이면 참

 # 배열 항목의 기본 값
- 정수(int, long, byte, ...) : 0
- 실수(float, double)        : 0.0
- 문자(char)                 : 0
- boolean                    : false

 # String 클래스의 주요 메소드
- charAt(인덱스 값) : 문자열에서 해당 인덱스 위치에 있는 문자 리턴
- length()         : 문자열의 길이 리턴
- equals("문자열")  : 문자열과 인수로 받은 문자열이 같은 지 여부 확인
- valueOf(값)       : 인수로 받은 값을 문자열로 변환하여 리턴
- toUpperCase()     : 문자열을 모두 대문자로 변환하여 리턴
- toLowerCase()     : 문자열을 모두 소문자로 변환하여 리턴
- isEmpty()         : 문자열의 길이가 0인 경우에 true를 리턴

 # Arrays 클래스의 주요 메소드
- fill(배열명, 값) : 전달받은 배열의 항목들을 값으로 초기화
- sort(배열명)     : 전달받은 배열을 오름차순으로 정렬
- toString(배열명) : 전달받은 배열의 항목 전체를 한 줄의 문자열로 변환하여 리턴
- copyOf(배열명)   : 전달받은 배열에서 해당 길이를 갖는 새 배열로 복사하여 리턴

 # Math 클래스의 주요 메소드
- random()      : 0.0 이상 1.0 미만의 임의의 실수 값을 리턴
- abs(값)       : 전달된 값의 절대값을 리턴
- max(값1, 값2) : 값1과 값2 중 더 큰 값을 리턴
- min(값1, 값2) : 값1과 값2 중 더 작은 값을 리턴
- ceil(값)      : 전달된 값의 소수 부분을 올린 값을 리턴
- floor(값)     : 전달된 값의 소수 부분을 버린 값을 리턴
- round(값)     : 전달된 값의 소수 첫째 자리에서 반올림한 값을 리턴
- pow(값1, 값2) : 값1의 값2승(값2=2이면 제곱)

 # 최대값 구하기(최소값 구하기)
- 최대값의 초기값으로 배열의 첫 번째 항목 혹은 배열이 갖지 않는 아주 작은 값을 지정
- 배열 항목을 차례대로 가져와서 현재 배열 항목 값이 현재의 최대값보다 크면 최대값을 현재 배열 항목 값으로 교체

 # 주이전 수에 있는 각 자리 숫자 추출하기
- 135 : 일의 자리 숫자 : 5                 <-- 135 % 10 = 5
        십의 자리 숫자 : 3 <-- 135/10 = 13 <-- 13 % 10 = 3
        백의 자리 숫자 : 1 <-- 13/10 = 1   <-- 1 % 10 = 1
        천의 자리 숫자 : 0 <-- 1/10 = 0    <-- 나눈 몫 = 0, 추출 작업 종료

 # 배열의 앞뒤 원소 2개씩 비교할때
- for(int i=0; i<arr.length-1; i++) -> arr[i]와 arr[i+1] 비교
- for(int i=1; i<arr.length; i++)   -> arr[i-1]와 arr[i] 비교

 # 득표수 등 counter 배열 생성
- int[] counter = new int[N+1]

 # 등수 rank 배열 생성
- int[] rank = new rank[N] 이후 1로 초기화

 # 6글자 돌아가며 추가 : answer += String.charAt(i%6);

 # 전위 연산자 vs 후위 연산자
- 전위 연산자
  - 변수 앞에 붙은 증감연산자에 의한 계산을 먼저 실행한 후 해당 변수에 대한 명령 실행
- 후위 연산자
  - 해당 변수에 대한 명령을 먼저 실행한 후에 변수 뒤에 붙은 증감연산자에 의한 계산을 수행

 # 알파벳 별 점수 부여
- answer += card.charAt(i) - 'a' + 1; // a와의 차이

 # 2차원 배열에서 개별 항목의 위치
- dy = {-1, 1, 0, 0} : 상하좌우 항목들을 가져오기 위한 행 인덱스 증감값
- dx = {0, 0, -1, 1} : 상하좌우 항목들을 가져오기 위한 열 인덱스 증감값

 # int to String, String to int
- int to String : Integer.toString(int)
- String to int : Integer.parseInt(String)


 # 주어진 수 거꾸로 뒤집기
- for(int i = 0; i < digit; i++) {
    int temp = number % 10;
    number = number / 10;
    ret = ret * 10 + temp;
  }

 # 최대공약수
- for(int i=min; i>=1; i--) {
    if(num1%i==0 && num2%i==0) {
        answer = i;
        break;
    }
  }

 # 최소공배수
- for(int i=1; i<=max; i++) {
    if((min*i)%max==0) {
        answer = min*i;
        break;
    }
  }

- for(int i=max; i<=min*max; i++) {
    if(i%min==0 && i%max==0) {
        answer = i;
        break;
    }
  }








