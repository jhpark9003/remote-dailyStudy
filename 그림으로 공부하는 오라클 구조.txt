# 그림으로 공부하는 오라클 구조

Chapter 1. I/O와 디스크의 관계
1.1 오라클을 이해하기 위한 필수 키워드
1.2 오라클과 디스크(하드디스크)
1.3 디스크의 동작
1.4 데이터를 보증하기 위한 디스크
1.5 요약

Chapter 2. 오라클의 여러 프로세스
2.1 오라클의 역할 이미지
2.2 데이터베이스의 데이터는 모두의 것
2.3 오라클이 여러 개의 프로세스로 구성된 이유
2.4 서버 프로세스와 백그라운드 프로세스의 역할
2.5 각 프로세스가 수행하는 처리
2.6 요약

Chapter 3. 캐시와 공유 메모리
3.1 어째서 캐시가 필요한 것인가?
3.2 그래서 캐시란 대체 무엇인가?
3.3 데이터는 블록 단위로 관리
3.4 캐시를 사용해서 인덱스 검색을 효율적으로
3.5 프로세스는 캐시를 공유
3.6 공유 메모리에 필요한 설정
3.7 공유 메모리는 어떤 식으로 보이는가?
3.8 버퍼 캐시를 정리하는 LRU 알고리즘
3.9 오라클뿐만이 아닌 OS나 스토리지에 대해서도 생각하자
3.10 요약

Chapter 4. SQL문 분석과 공유 풀
4.1 SQL문의 분석과 공유 풀을 왜 배워야 하는가?
4.2 SQL문과 일반적인 프로그래밍 언어의 차이
4.3 서버 프로세스와 분석
4.4 실행 계획이 최적이라는 것을 판단하기 위해서는?
4.5 공유 풀의 동작과 구조
4.6 수치로 알아보는 분석과 공유 풀의 정보
4.7 요약

Chapter 5. 오라클의 기동과 정지
5.1 기동과 정지를 왜 배워야 하는가?
5.2 오라클의 기동/정지의 개요
5.3 업무의 시작에 해당하는 오라클의 기동
5.4 인스턴스, 데이터베이스, 그리고 주요 파일의 구성
5.5 기동 처리의 흐름과 내부 동작
5.6 업무 종료에 해당하는 오라클의 정지
5.7 데이터베이스를 수동으로 생성하기
5.8 요약

Chapter 6. 커넥션과 서버 프로세스의 생성
6.1 애플리케이션에서의 접속을 왜 배워야 하는가?
6.2 오라클의 접속 동작
6.3 접속 동작의 확인
6.4 정지나 리스너의 상태 확인
6.5 성능을 개선하기 위해서는?
6.6 요약

Chapter 7. 오라클의 데이터 구조
7.1 오라클의 데이터 구조를 왜 배워야 하는가?
7.2 가변 길이 데이터를 관리할 프로그램을 만들기 위해서는?
7.3 오라클의 데이터 구조
7.4 데이터 구조에는 어떤 것들이 있는가?
7.5 실제 흐름을 따라 각 동작을 확인
7.6 프로세스에서 본 데이터 구조
7.7 요약

Chapter 8. 오라클의 대기와 Lock
8.1 대기와 오라클의 Lock을 왜 배워야 하는가?
8.2 데이터베이스에 Lock이 필요한 이유
8.3 대기와 Lock 대기
8.4 Latch의 구조
8.5 요약

Chapter 9. REDO와 UNDO의 동작
9.1 REDO와 UNDO를 왜 배워야 하는가?
9.2 지속성을 구현하기 위해서는
9.3 REDO와 UNDO의 개념
9.4 REDO의 구조
9.5 UNDO의 구조
9.6 여러 상황에서 REDO와 UNDO의 동작
9.7 요약

Chapter 10. 백업/복구의 구조와 동작
10.1 백업/복구를 왜 배워야 하는가?
10.2 백업/복구에 필요한 지식의 복습
10.3 백업의 종류와 특징
10.4 데이터베이스 손상의 예
10.5 기본적인 복구의 종류와 동작
10.6 기본적인 복구의 흐름(데이터베이스 전체의 복구)
10.7 그 외의 복구
10.8 요약

Chapter 11. 백그라운드 프로세스의 동작과 역할
11.1 백그라운드 프로세스를 왜 배워야 하는가?
11.2 백그라운드 프로세스와 서버 프로세스의 관계
11.3 DBWR의 동작과 역할
11.4 LGWR의 동작과 역할
11.5 SMON의 동작과 역할
11.6 PMON의 동작과 역할
11.7 LREG의 동작과 역할
11.8 ARCH의 동작과 역할
11.9 그 외의 백그라운드 프로세스
11.10 요약

Chapter 12.오라클 아키텍처와 동작에 관한 Q&A
12.1 지금까지의 복습
12.2 오라클의 동작에 관한 질문
12.3 모니터링/운영에 관한 질문
12.4 (해답과 해설)오라클의 동작에 관한 질문
12.5 (해답과 해설)모니터링/운영에 관한 질문
12.6 요약


- 아키텍처와 동작을 지속적으로 설명하여 머릿속에서 이미지를 떠올릴 수 있도록 한다.
- 가능한 한 오라클 이외의 용어(it 기본 용어)를 사용해서 설명한다.
- 명령어를 설명하는 것은 이 책의 주목적이 아니다.

- 오라클이라고 하더라도 결국 그 실체는 디스크나 네트워크를 사용하는 OS상에서의 애플리케이션에 지나지 않는다.
- 이 책의 구체적인 목표는 '오라클의 기본적인 아키텍처를 이해하는 것'이다.

 # 오라클을 이해하기 위한 필수 키워드
1. 병렬 처리를 가능케 하고 높은 처리량을 실현한다.
2. 응답 시간(response time)을 중시한다.
3. 커밋(COMMIT)한 데이터는 지킨다.

- 어떻게 I/O의 대기 시간을 줄일까?
시퀀셜 액세스
 - 시퀀셜(sequential)은 '순서를 따라서'라는 의미의 '순차'를 뜻하며, 시작점에서부터 마지막까지 중간 부분을 빠트리지 않고 전부 액세스(읽기/쓰기)하는 것을 의미합니다.
 - 메모리에 테이블의 데이터가 없으면 풀 스캔(Full Scan, 테이블의 모든 데이터를 읽어오는 것)할 때 시퀀셜 액세스가 발생합니다.

랜덤 액세스
 - 디스크의 관점에서 생각해보면 랜덤 액세스는 비효율적인 부분이 존재한다.

- 시퀀셜 액세스는 'db file scattered read'라고 표시되며, 랜덤 액세스는 'db file sequential read'라고 표시된다.
  반대로 되어 있는 것이 아닌가라는 생각도 들지만, 표시가 잘못되어 있는 것은 아니다.
  오라클은 블록 단위로 데이터를 읽고 쓰며, 메모리에 배치해둔다.
  시퀀셜 액세스는 '순차로 읽는다'라는 의미로, 여러 블록을 한꺼번에 빠짐없이 읽어온다. 이때 읽어온 여러 블록은 메모리상에 연속되지 않은 형태로 놓인다. 따라서 'scattered'라고 표현한다.
  그에 반해 랜덤 액세스에서 읽어오는 데이터 블록은 한 번에 한 개이며, 메모리 공간에 반드시 연속적으로 놓인다. 따라서 'sequential'이라고 표현한다.
  한번 읽어온 블록을 메모리에 어떻게 배치하는지에 따라 표현하는 방법을 다르게 한 것이다.

 # 1.5 요약
- 디스크가 회전하고 있는 이미지
- 헤드가 움직이는 것과 회전해 오기를 기다리고 있어서 I/O에 시간이 걸리는 이미지
- 인덱스로 인해 해당 데이터에 빠르게 접근할 수 있다(테이블을 맨 앞에서부터 끝까지 풀 스캔하지 않아도 된다)는 이미지

- SSD는 플래시 메모리를 사용한 저장 장치입니다. HDD의 자기 디스크와는 다르게 주소로 표시되는 저장 공간에 데이터를 보존합니다.
  따라서 디스크의 회전 등 물리적인 동작을 필요로 하지 않고, 빠르게 데이터를 보존하고 꺼내올 수가 있습니다. 또한, 디스크에서 필요한 회전 등의 기계적인 구조 역시 필요 없으므로 충격에도 강합니다.

- 오라클을 포함한 DBMS(데이터베이스 관리 시스템)도 기본적인 동작은 '데이터를 짐처럼 맡아서 보관하고, 요구에 따라 데이터를 반환한다'라는 점에서 꽤 비슷합니다.

- 대부분의 시스템에서 애플리케이션은 JDBC(Java DataBase Connectivity)나 ODP.NET(Oracle Data Provider for .NET), Pro*C(오라클에서 사용하는 C언어 프리 컴파일러) 같은 것을 통해 오라클에서 SQL문을 수행합니다.
  SQL*Plus는 대부분 데이터베이스의 관리(테이블이나 인덱스의 생성 및 사람이 수동으로 직접 데이터를 검색하는 작업 등)를 위해서 사용합니다.

- 프로세스는 실행 중인 상태에 있는 프로그램을 의미합니다. 실행 중인 상태이기 때문에 메모리나 자원을 가지고 있습니다. 다르게 표현하자면 실체화(materialization)했다고 할 수 있습니다.
  프로세스를 다르게 비유하자면 프로그램을 따라서 일하는 난쟁이(작은 사람)와 같습니다. 유닉스(UNIX)상에 프로그램이 여러 개 실행되어 있다고 해도 그것들은 각각 다른 사람(프로세스)이므로 CPU가 여러 개 있다면 동시에 처리할 수 있습니다.
  이에 비해 스레드는 프로세스 내에 존재하는 실행 단위를 말합니다. 하나의 프로세스 안에서 병렬로 작업을 처리하고 싶을 때 사용합니다.
  어느 쪽이든 병렬로 처리하기 위한 구조이지만, 가장 다른 점은 부하의 크기와 메모리를 공유하는지의 여부입니다. 프로세스는 각자 독립적으로 수행되어 자원을 독자적으로 사용하므로 부하가 크고, 메모리를 공유하지 않습니다. 스레드는 한 프로세스 안에서 수행되므로 부하가 적지만 스레드끼리 메모리를 공유하므로 주의해서 사용해야 합니다.

- 오라클은 같은 프로세스가 여러 개 작동한 느것이 아닙니다. 실은 다른 역할을 가진 여러 가지 프로세스가 존재하고 있습니다.

- 오라클은 다음의 두 가지 프로세스로 구성되어 있습니다.
  - 서버 프로세스(SQL문을 처리하는 프로세스)
  - 백그라운드 프로세스(주로 서버 프로세스를 지원하는 프로세스)

- 오라클 클라이언트는 서버 프로세스와 통신(대화)합니다. 따라서 서버 프로세스는 일반적인 회사에서 말하는 '고객 담당'에 해당합니다.
  그리고 고객 담당을 지원하는 각종 지원 스태프(백그라운드 프로세스)가 창고 업자인 오라클에도 있습니다.

- 오라클에서 수행하는 주요 처리는 다음과 같습니다.
  1) SQL문의 수신
  2) SQL문의 파싱(어떤 테이블에 어떻게 접근해야 하는지를 생각하는 작업)
  3) 데이터 읽기(디스크에서 읽어온다)
  4) 데이터 기록(디스크에 기록한다)
  5) SQL문의 결과 회신
  6) 로그 기록(데이터의 변경 로그를 디스크에 기록)
  7) 각종 정리(프로세스의 비정상 종료로 인한 아무도 사용하지 않는 LOCK의 해제 등)
  8) 로그 보관(아카이브)

- 포어그라운드 프로세스(foreground process)
서버 프로세스를 말합니다. 백그라운드와 반대의 의미를 가진 서버 프로세스는 이렇게 불리기도 합니다. 단, 이 용어는 현장에서 사용되기보다는 오라클에서 사용하는 도구(툴)들 내에 표시되는 용어로 사용되고 있습니다.

 # 2.6 요약
- 데이터베이스는 모두 공유해서 사용한다
- 애플리케이션이나 SQL*Plus 같은 오라클 클라이언트가 여러 개 존재하고, 여러 개의 SQL문이 오라클에 전달된다
- 오라클 위에서 여러 개의 SQL문이 동시에 동작하고 있다(PC에서의 엑셀과는 다르다)
- 서버 프로세스는 SQL문의 결과를 가능하면 빠르게 회신하기 위한 일을 한다(고객을 최우선으로 영업한다)
- 서버 프로세스를 도와주는 백그라운드 프로세스가 존재한다(지원 스태프)

- 오라클 RAC란?
RAC란 Real Application Clusters의 약자로서, 오라클 클러스터웨어(Clusterware)를 활용한 오라클 데이터베이스의 클러스터 기술을 말합니다. 간단하게 말하면 여러 개의 서버상에 가동된 인스턴스를 하나의 데이터베이스처럼 사용할 수 있습니다. 여러 개의 서버로 구성되어 있지만 데이터의 일관성을 유지하기 위해 스토리지는 함께 사용합니다.
일반적으로 여러 대의 인스턴스로 구성한 것을 RAC 구성, 한 개의 인스턴스로 구성한 것을 싱글 구성이라고 부릅니다.
일반적인 HA(High Availability, 고가용성) 구성과 비교해서 RAC 구성이 가진 특징은 각 서버가 액티브(active)/스탠바이(standby)가 아닌 액티브/액티브 구성이므로 서버의 CPU나 메모리 같은 자원을 100% 활용할 수 있다는 점입니다. 즉, 두 대 이상의 저렴한 서버가 비싼 서버 한 대 보다 강력하게 동작합니다. 그러므로 사용 가능한 자원이라면 모두 사용하는 것이 이득일 것입니다.
그리고 장애와 관련된 가용성 역시 향상됩니다. 한 개의 인스턴스에 장애가 발생하더라도 남은 인스턴스로 작업을 처리할 수 있기 때문에 지속적인 운영이 가능합니다.
또한, RAC를 구성하는 서버를 추가/삭제할 수도 있습니다. 서버를 추가한다는 것은 CPU와 메모리를 추가하는 것에 상응하며, 당연히 가용성도 향상됩니다. 아울러 시스템 요건의 변화에 따라 유연하게 대응할 수 있다는 점도 매력적입니다.
감이 좋으신 독자분께서는 '스토리지를 함께 사용하기 때문에 변경 정보는 디스크에 기록될 때까지 다른 서버에서 확인할 수 없는 것이 아닌가?'라고 생각하실 수도 있습니다. 하지만, RAC는 메모리에 캐시되어 있는 블록을 서버 간에 공유하므로 디스크의 I/O를 기다릴 필요 없이 데이터의 일관성을 유지할 수 있는 구조를 가지고 있습니다.

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 





