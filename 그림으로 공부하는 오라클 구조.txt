# 그림으로 공부하는 오라클 구조

Chapter 1. I/O와 디스크의 관계
1.1 오라클을 이해하기 위한 필수 키워드
1.2 오라클과 디스크(하드디스크)
1.3 디스크의 동작
1.4 데이터를 보증하기 위한 디스크
1.5 요약

Chapter 2. 오라클의 여러 프로세스
2.1 오라클의 역할 이미지
2.2 데이터베이스의 데이터는 모두의 것
2.3 오라클이 여러 개의 프로세스로 구성된 이유
2.4 서버 프로세스와 백그라운드 프로세스의 역할
2.5 각 프로세스가 수행하는 처리
2.6 요약

Chapter 3. 캐시와 공유 메모리
3.1 어째서 캐시가 필요한 것인가?
3.2 그래서 캐시란 대체 무엇인가?
3.3 데이터는 블록 단위로 관리
3.4 캐시를 사용해서 인덱스 검색을 효율적으로
3.5 프로세스는 캐시를 공유
3.6 공유 메모리에 필요한 설정
3.7 공유 메모리는 어떤 식으로 보이는가?
3.8 버퍼 캐시를 정리하는 LRU 알고리즘
3.9 오라클뿐만이 아닌 OS나 스토리지에 대해서도 생각하자
3.10 요약

Chapter 4. SQL문 분석과 공유 풀
4.1 SQL문의 분석과 공유 풀을 왜 배워야 하는가?
4.2 SQL문과 일반적인 프로그래밍 언어의 차이
4.3 서버 프로세스와 분석
4.4 실행 계획이 최적이라는 것을 판단하기 위해서는?
4.5 공유 풀의 동작과 구조
4.6 수치로 알아보는 분석과 공유 풀의 정보
4.7 요약

Chapter 5. 오라클의 기동과 정지
5.1 기동과 정지를 왜 배워야 하는가?
5.2 오라클의 기동/정지의 개요
5.3 업무의 시작에 해당하는 오라클의 기동
5.4 인스턴스, 데이터베이스, 그리고 주요 파일의 구성
5.5 기동 처리의 흐름과 내부 동작
5.6 업무 종료에 해당하는 오라클의 정지
5.7 데이터베이스를 수동으로 생성하기
5.8 요약

Chapter 6. 커넥션과 서버 프로세스의 생성
6.1 애플리케이션에서의 접속을 왜 배워야 하는가?
6.2 오라클의 접속 동작
6.3 접속 동작의 확인
6.4 정지나 리스너의 상태 확인
6.5 성능을 개선하기 위해서는?
6.6 요약

Chapter 7. 오라클의 데이터 구조
7.1 오라클의 데이터 구조를 왜 배워야 하는가?
7.2 가변 길이 데이터를 관리할 프로그램을 만들기 위해서는?
7.3 오라클의 데이터 구조
7.4 데이터 구조에는 어떤 것들이 있는가?
7.5 실제 흐름을 따라 각 동작을 확인
7.6 프로세스에서 본 데이터 구조
7.7 요약

Chapter 8. 오라클의 대기와 Lock
8.1 대기와 오라클의 Lock을 왜 배워야 하는가?
8.2 데이터베이스에 Lock이 필요한 이유
8.3 대기와 Lock 대기
8.4 Latch의 구조
8.5 요약

Chapter 9. REDO와 UNDO의 동작
9.1 REDO와 UNDO를 왜 배워야 하는가?
9.2 지속성을 구현하기 위해서는
9.3 REDO와 UNDO의 개념
9.4 REDO의 구조
9.5 UNDO의 구조
9.6 여러 상황에서 REDO와 UNDO의 동작
9.7 요약

Chapter 10. 백업/복구의 구조와 동작
10.1 백업/복구를 왜 배워야 하는가?
10.2 백업/복구에 필요한 지식의 복습
10.3 백업의 종류와 특징
10.4 데이터베이스 손상의 예
10.5 기본적인 복구의 종류와 동작
10.6 기본적인 복구의 흐름(데이터베이스 전체의 복구)
10.7 그 외의 복구
10.8 요약

Chapter 11. 백그라운드 프로세스의 동작과 역할
11.1 백그라운드 프로세스를 왜 배워야 하는가?
11.2 백그라운드 프로세스와 서버 프로세스의 관계
11.3 DBWR의 동작과 역할
11.4 LGWR의 동작과 역할
11.5 SMON의 동작과 역할
11.6 PMON의 동작과 역할
11.7 LREG의 동작과 역할
11.8 ARCH의 동작과 역할
11.9 그 외의 백그라운드 프로세스
11.10 요약

Chapter 12.오라클 아키텍처와 동작에 관한 Q&A
12.1 지금까지의 복습
12.2 오라클의 동작에 관한 질문
12.3 모니터링/운영에 관한 질문
12.4 (해답과 해설)오라클의 동작에 관한 질문
12.5 (해답과 해설)모니터링/운영에 관한 질문
12.6 요약


- 아키텍처와 동작을 지속적으로 설명하여 머릿속에서 이미지를 떠올릴 수 있도록 한다.
- 가능한 한 오라클 이외의 용어(it 기본 용어)를 사용해서 설명한다.
- 명령어를 설명하는 것은 이 책의 주목적이 아니다.

- 오라클이라고 하더라도 결국 그 실체는 디스크나 네트워크를 사용하는 OS상에서의 애플리케이션에 지나지 않는다.
- 이 책의 구체적인 목표는 '오라클의 기본적인 아키텍처를 이해하는 것'이다.

 # 오라클을 이해하기 위한 필수 키워드
1. 병렬 처리를 가능케 하고 높은 처리량을 실현한다.
2. 응답 시간(response time)을 중시한다.
3. 커밋(COMMIT)한 데이터는 지킨다.

- 어떻게 I/O의 대기 시간을 줄일까?
시퀀셜 액세스
 - 시퀀셜(sequential)은 '순서를 따라서'라는 의미의 '순차'를 뜻하며, 시작점에서부터 마지막까지 중간 부분을 빠트리지 않고 전부 액세스(읽기/쓰기)하는 것을 의미합니다.
 - 메모리에 테이블의 데이터가 없으면 풀 스캔(Full Scan, 테이블의 모든 데이터를 읽어오는 것)할 때 시퀀셜 액세스가 발생합니다.

랜덤 액세스
 - 디스크의 관점에서 생각해보면 랜덤 액세스는 비효율적인 부분이 존재한다.

- 시퀀셜 액세스는 'db file scattered read'라고 표시되며, 랜덤 액세스는 'db file sequential read'라고 표시된다.
  반대로 되어 있는 것이 아닌가라는 생각도 들지만, 표시가 잘못되어 있는 것은 아니다.
  오라클은 블록 단위로 데이터를 읽고 쓰며, 메모리에 배치해둔다.
  시퀀셜 액세스는 '순차로 읽는다'라는 의미로, 여러 블록을 한꺼번에 빠짐없이 읽어온다. 이때 읽어온 여러 블록은 메모리상에 연속되지 않은 형태로 놓인다. 따라서 'scattered'라고 표현한다.
  그에 반해 랜덤 액세스에서 읽어오는 데이터 블록은 한 번에 한 개이며, 메모리 공간에 반드시 연속적으로 놓인다. 따라서 'sequential'이라고 표현한다.
  한번 읽어온 블록을 메모리에 어떻게 배치하는지에 따라 표현하는 방법을 다르게 한 것이다.

 # 1.5 요약
- 디스크가 회전하고 있는 이미지
- 헤드가 움직이는 것과 회전해 오기를 기다리고 있어서 I/O에 시간이 걸리는 이미지
- 인덱스로 인해 해당 데이터에 빠르게 접근할 수 있다(테이블을 맨 앞에서부터 끝까지 풀 스캔하지 않아도 된다)는 이미지

- SSD는 플래시 메모리를 사용한 저장 장치입니다. HDD의 자기 디스크와는 다르게 주소로 표시되는 저장 공간에 데이터를 보존합니다.
  따라서 디스크의 회전 등 물리적인 동작을 필요로 하지 않고, 빠르게 데이터를 보존하고 꺼내올 수가 있습니다. 또한, 디스크에서 필요한 회전 등의 기계적인 구조 역시 필요 없으므로 충격에도 강합니다.

- 오라클을 포함한 DBMS(데이터베이스 관리 시스템)도 기본적인 동작은 '데이터를 짐처럼 맡아서 보관하고, 요구에 따라 데이터를 반환한다'라는 점에서 꽤 비슷합니다.

- 대부분의 시스템에서 애플리케이션은 JDBC(Java DataBase Connectivity)나 ODP.NET(Oracle Data Provider for .NET), Pro*C(오라클에서 사용하는 C언어 프리 컴파일러) 같은 것을 통해 오라클에서 SQL문을 수행합니다.
  SQL*Plus는 대부분 데이터베이스의 관리(테이블이나 인덱스의 생성 및 사람이 수동으로 직접 데이터를 검색하는 작업 등)를 위해서 사용합니다.

- 프로세스는 실행 중인 상태에 있는 프로그램을 의미합니다. 실행 중인 상태이기 때문에 메모리나 자원을 가지고 있습니다. 다르게 표현하자면 실체화(materialization)했다고 할 수 있습니다.
  프로세스를 다르게 비유하자면 프로그램을 따라서 일하는 난쟁이(작은 사람)와 같습니다. 유닉스(UNIX)상에 프로그램이 여러 개 실행되어 있다고 해도 그것들은 각각 다른 사람(프로세스)이므로 CPU가 여러 개 있다면 동시에 처리할 수 있습니다.
  이에 비해 스레드는 프로세스 내에 존재하는 실행 단위를 말합니다. 하나의 프로세스 안에서 병렬로 작업을 처리하고 싶을 때 사용합니다.
  어느 쪽이든 병렬로 처리하기 위한 구조이지만, 가장 다른 점은 부하의 크기와 메모리를 공유하는지의 여부입니다. 프로세스는 각자 독립적으로 수행되어 자원을 독자적으로 사용하므로 부하가 크고, 메모리를 공유하지 않습니다. 스레드는 한 프로세스 안에서 수행되므로 부하가 적지만 스레드끼리 메모리를 공유하므로 주의해서 사용해야 합니다.

- 오라클은 같은 프로세스가 여러 개 작동한 느것이 아닙니다. 실은 다른 역할을 가진 여러 가지 프로세스가 존재하고 있습니다.

- 오라클은 다음의 두 가지 프로세스로 구성되어 있습니다.
  - 서버 프로세스(SQL문을 처리하는 프로세스)
  - 백그라운드 프로세스(주로 서버 프로세스를 지원하는 프로세스)

- 오라클 클라이언트는 서버 프로세스와 통신(대화)합니다. 따라서 서버 프로세스는 일반적인 회사에서 말하는 '고객 담당'에 해당합니다.
  그리고 고객 담당을 지원하는 각종 지원 스태프(백그라운드 프로세스)가 창고 업자인 오라클에도 있습니다.

- 오라클에서 수행하는 주요 처리는 다음과 같습니다.
  1) SQL문의 수신
  2) SQL문의 파싱(어떤 테이블에 어떻게 접근해야 하는지를 생각하는 작업)
  3) 데이터 읽기(디스크에서 읽어온다)
  4) 데이터 기록(디스크에 기록한다)
  5) SQL문의 결과 회신
  6) 로그 기록(데이터의 변경 로그를 디스크에 기록)
  7) 각종 정리(프로세스의 비정상 종료로 인한 아무도 사용하지 않는 LOCK의 해제 등)
  8) 로그 보관(아카이브)

- 포어그라운드 프로세스(foreground process)
서버 프로세스를 말합니다. 백그라운드와 반대의 의미를 가진 서버 프로세스는 이렇게 불리기도 합니다. 단, 이 용어는 현장에서 사용되기보다는 오라클에서 사용하는 도구(툴)들 내에 표시되는 용어로 사용되고 있습니다.

 # 2.6 요약
- 데이터베이스는 모두 공유해서 사용한다
- 애플리케이션이나 SQL*Plus 같은 오라클 클라이언트가 여러 개 존재하고, 여러 개의 SQL문이 오라클에 전달된다
- 오라클 위에서 여러 개의 SQL문이 동시에 동작하고 있다(PC에서의 엑셀과는 다르다)
- 서버 프로세스는 SQL문의 결과를 가능하면 빠르게 회신하기 위한 일을 한다(고객을 최우선으로 영업한다)
- 서버 프로세스를 도와주는 백그라운드 프로세스가 존재한다(지원 스태프)

- 오라클 RAC란?
RAC란 Real Application Clusters의 약자로서, 오라클 클러스터웨어(Clusterware)를 활용한 오라클 데이터베이스의 클러스터 기술을 말합니다. 간단하게 말하면 여러 개의 서버상에 가동된 인스턴스를 하나의 데이터베이스처럼 사용할 수 있습니다. 여러 개의 서버로 구성되어 있지만 데이터의 일관성을 유지하기 위해 스토리지는 함께 사용합니다.
일반적으로 여러 대의 인스턴스로 구성한 것을 RAC 구성, 한 개의 인스턴스로 구성한 것을 싱글 구성이라고 부릅니다.
일반적인 HA(High Availability, 고가용성) 구성과 비교해서 RAC 구성이 가진 특징은 각 서버가 액티브(active)/스탠바이(standby)가 아닌 액티브/액티브 구성이므로 서버의 CPU나 메모리 같은 자원을 100% 활용할 수 있다는 점입니다. 즉, 두 대 이상의 저렴한 서버가 비싼 서버 한 대 보다 강력하게 동작합니다. 그러므로 사용 가능한 자원이라면 모두 사용하는 것이 이득일 것입니다.
그리고 장애와 관련된 가용성 역시 향상됩니다. 한 개의 인스턴스에 장애가 발생하더라도 남은 인스턴스로 작업을 처리할 수 있기 때문에 지속적인 운영이 가능합니다.
또한, RAC를 구성하는 서버를 추가/삭제할 수도 있습니다. 서버를 추가한다는 것은 CPU와 메모리를 추가하는 것에 상응하며, 당연히 가용성도 향상됩니다. 아울러 시스템 요건의 변화에 따라 유연하게 대응할 수 있다는 점도 매력적입니다.
감이 좋으신 독자분께서는 '스토리지를 함께 사용하기 때문에 변경 정보는 디스크에 기록될 때까지 다른 서버에서 확인할 수 없는 것이 아닌가?'라고 생각하실 수도 있습니다. 하지만, RAC는 메모리에 캐시되어 있는 블록을 서버 간에 공유하므로 디스크의 I/O를 기다릴 필요 없이 데이터의 일관성을 유지할 수 있는 구조를 가지고 있습니다.

- 캐시는 가장 간단한 튜닝 항목이자 잘 알려진 기능 중 하나이지만, 아키텍처를 제대로 이해하고 있지 않으면 생각지도 못한 부분에서 '가져오고 싶었던 데이터가 캐시에 존재하지 않아 성능이 좋지 않다'와 같은 결과를 초래합니다.   캐시의 동작을 잘 이해해서 데이터베이스의 성능을 올려줍시다.

- 어느 정도 공유 메모리를 알게 되었으니 설정 방법을 알아보도록 하겠습니다. 오라클의 설정 파일인 spfileXXXX.ora(XXXX에는 데이터베이스를 식별하는 ID가 들어갑니다)에는 버퍼 캐시의 크기를 결정하는 'DB_CACHE_SIZE'라는 파   라미터가 있습니다. [버퍼 캐시의 크기를 설정하는 파라미터 중 'DB_BLOCK_BUFFERS'는 오라클 12.2부터는 권고하지 않습니다.]
  앞에서 설명한 것처럼 버퍼 캐시는 성능과 직결되기 때문에 크기를 정할 때 신중히 결정해야 합니다.
- 공유 메모리의 설정 예(리눅스의 경우)
  # /sbin/sysctl -a | grep shm
  kernel.shmall = 2097152
  kernel.shmmax = 4294967295
  kernel.shmmni - 4096
  => 'shm'으로 시작하는 부분이 공유메모리의 설정

- 버퍼 캐시의 크기와 관련된 최근의 이야기
지금까지 설명했던 것처럼 버퍼 캐시의 설정은 성능에 직결되는 중요한 부분입니다. 그렇기 때문에 독자 여러분께서는 '그럼 대체 어떻게 버퍼 캐시의 크기를 정해야 하는가?'라는 의문이 들 겁니다.
데이터베이스를 새로 설치할 때와 같이 적절한 크기를 알 수 없는 경우에는 임시로 처음 크기를 크게 잡아 놓습니다. 그 후에 대표적인 업무를 실제로 돌려보면서 관련된 통계를 기반으로 조정하는 방법이 있습니다.
그때 도움이 될 수 있는 힌트를 드리면, 버퍼 캐시 크기마다 물리 읽기 수를 예측하는 버퍼 캐시 어드바이저(V$DB_CACHE_ADVICE)나 버퍼 캐시 내에서 요청받은 블록을 꺼내온 빈도를 의미하는 버퍼 캐시 히트율이 있습니다. 버퍼 캐시의 튜닝과 관련된 상세 내용을 알고 싶으신 분은 아래의 매뉴얼을 참고하세요. [참고 : 오라클 공식 문서 'Database Performance Tuning Guide'의 13.Tuning the Database Buffer Cache]
또한, 버퍼 캐시를 아예 설정하지 않는 접근 방법도 있습니다. 부하의 정도에 따라 오라클이 자동으로 조절하도록 설정하는 방법입니다. 공유 메모리(SGA)에는 버퍼 캐시 이외에도 SQL의 파싱 결과를 보관하는 공유 풀과 같은 다른 영역이 존재하며, 각각 설정하게 될 경우 크기를 하나하나 검토해야 합니다. 이런 영역들의 크기를 개별적으로 설정해서 관리하는 것이 아니라 SGA만 크기를 설정해 놓으면 나머지는 오라클이 알아서 관리하는 것을 '자동 공유 메모리 관리(Automatic Shared Memory Management)'라고 부릅니다(PGA 내의 영역을 자동으로 관리하는 '자동 PGA 메모리 관리(AUtomatic PGA Memory Management)'나, SGA와 PGA 간의 비율도 자동으로 조정하는 '자동 메모리 관리(Automatic Memory Management)'라는 기능도 있습니다).
이 기능들을 사용하면 크기를 예측하느라 고생하지 않아도 부하의 정도에 따라 오라클이 알아서 조정해주기 때문에 최근에는 자동으로 설정해놓고 사용하는 곳들도 많아지는 추세입니다. 다만, 저는 자동 공유 메모리를 설정할 때는 DB_CACHE_SIZE를 함께 설정하는 것을 추천합니다. 자동 공유 메모리를 설정한 상태로 DB_CACHE_SIZE를 설정하면 하한값으로서 동작하므로 혹여라도 버퍼 캐시의 영역이 다른 영역에 잡아먹혀서 성능이 나빠지는 상황을 방지할 수 있기 때문입니다.

- '세마포어(semaphore)'란?
세마포어는 OS가 제공하는 자원을 관리하기 위한 장치의 일종으로, 자원의 수에 비해 사용하고자 하는 프로세스의 수가 많을 경우에 순서대로 자원을 사용할 수 있도록 프로세스 제어를 수행합니다. 여러 개의 프로세스가 동작하는 오라클도 프로세스 제어에 세마포어를 사용하고 있습니다.
  # /sbin/sysctl -a | grep sem
  kernel.sem = 250 32000 100 128
  => 'sem'으로 시작하는 설정이 세마포어의 설정
기본적으로 세마포어도 매뉴얼에서 지시하는 대로 설정하면 문제는 없지만, 오라클 이외의 애플리케이션에서 사용할 수도 있으므로 오라클을 기동할 때 세마포어가 부족하다는 의미의 메시지가 나타나면 늘리는 것을 검토해야 합니다. 또한, 아무도 사용하지 않는 세마포어가 OS에 남아있는 경우도 있으므로 정리할 필요가 있습니다. 그럴 때는 DBA가 ipcs 명령어나 ipcrm 명령어를 사용해서 정리하면 됩니다.

- 버퍼 캐시는 자주 사용하는 데이터를 더 빠르게 가져오기 위해 존재합니다. 또한, 버퍼 캐시의 크기는 한정되어 있으므로, 누군가가 어떤 식으로든 관리하고 정리해야 합니다. 캐시에 사용하는 알고리즘 중 일반적으로 알려진 것이 'LRU(Least Recently Used) 알고리즘'입니다.

- 자주 사용하지 않는 데이터를 버퍼 캐시에 둘 필요는 없습니다. 구체적인 예를 들자면, 데이터가 많은 테이블을 풀 스캔한 데이터는 적재해두더라도 사용하는 경우는 별로 없으며, 오히려 풀 스캔한 데이터를 적재해 둠으로써 자주 사용하는 데이터를 캐시에서 쫓아내는 일이 발생하게 됩니다. 따라서 오라클은 큰 테이블이라고 판단하면 버퍼 캐시로 블록(데이터)을 적재하지 않으며, 풀 스캔했을 때의 데이터는 일반적으로 버퍼 캐시에 적재되지 않는다고 생각하세요.

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 





