# 그림으로 공부하는 오라클 구조

Chapter 1. I/O와 디스크의 관계
1.1 오라클을 이해하기 위한 필수 키워드
1.2 오라클과 디스크(하드디스크)
1.3 디스크의 동작
1.4 데이터를 보증하기 위한 디스크
1.5 요약

Chapter 2. 오라클의 여러 프로세스
2.1 오라클의 역할 이미지
2.2 데이터베이스의 데이터는 모두의 것
2.3 오라클이 여러 개의 프로세스로 구성된 이유
2.4 서버 프로세스와 백그라운드 프로세스의 역할
2.5 각 프로세스가 수행하는 처리
2.6 요약

Chapter 3. 캐시와 공유 메모리
3.1 어째서 캐시가 필요한 것인가?
3.2 그래서 캐시란 대체 무엇인가?
3.3 데이터는 블록 단위로 관리
3.4 캐시를 사용해서 인덱스 검색을 효율적으로
3.5 프로세스는 캐시를 공유
3.6 공유 메모리에 필요한 설정
3.7 공유 메모리는 어떤 식으로 보이는가?
3.8 버퍼 캐시를 정리하는 LRU 알고리즘
3.9 오라클뿐만이 아닌 OS나 스토리지에 대해서도 생각하자
3.10 요약

Chapter 4. SQL문 분석과 공유 풀
4.1 SQL문의 분석과 공유 풀을 왜 배워야 하는가?
4.2 SQL문과 일반적인 프로그래밍 언어의 차이
4.3 서버 프로세스와 분석
4.4 실행 계획이 최적이라는 것을 판단하기 위해서는?
4.5 공유 풀의 동작과 구조
4.6 수치로 알아보는 분석과 공유 풀의 정보
4.7 요약

Chapter 5. 오라클의 기동과 정지
5.1 기동과 정지를 왜 배워야 하는가?
5.2 오라클의 기동/정지의 개요
5.3 업무의 시작에 해당하는 오라클의 기동
5.4 인스턴스, 데이터베이스, 그리고 주요 파일의 구성
5.5 기동 처리의 흐름과 내부 동작
5.6 업무 종료에 해당하는 오라클의 정지
5.7 데이터베이스를 수동으로 생성하기
5.8 요약

Chapter 6. 커넥션과 서버 프로세스의 생성
6.1 애플리케이션에서의 접속을 왜 배워야 하는가?
6.2 오라클의 접속 동작
6.3 접속 동작의 확인
6.4 정지나 리스너의 상태 확인
6.5 성능을 개선하기 위해서는?
6.6 요약

Chapter 7. 오라클의 데이터 구조
7.1 오라클의 데이터 구조를 왜 배워야 하는가?
7.2 가변 길이 데이터를 관리할 프로그램을 만들기 위해서는?
7.3 오라클의 데이터 구조
7.4 데이터 구조에는 어떤 것들이 있는가?
7.5 실제 흐름을 따라 각 동작을 확인
7.6 프로세스에서 본 데이터 구조
7.7 요약

Chapter 8. 오라클의 대기와 Lock
8.1 대기와 오라클의 Lock을 왜 배워야 하는가?
8.2 데이터베이스에 Lock이 필요한 이유
8.3 대기와 Lock 대기
8.4 Latch의 구조
8.5 요약

Chapter 9. REDO와 UNDO의 동작
9.1 REDO와 UNDO를 왜 배워야 하는가?
9.2 지속성을 구현하기 위해서는
9.3 REDO와 UNDO의 개념
9.4 REDO의 구조
9.5 UNDO의 구조
9.6 여러 상황에서 REDO와 UNDO의 동작
9.7 요약

Chapter 10. 백업/복구의 구조와 동작
10.1 백업/복구를 왜 배워야 하는가?
10.2 백업/복구에 필요한 지식의 복습
10.3 백업의 종류와 특징
10.4 데이터베이스 손상의 예
10.5 기본적인 복구의 종류와 동작
10.6 기본적인 복구의 흐름(데이터베이스 전체의 복구)
10.7 그 외의 복구
10.8 요약

Chapter 11. 백그라운드 프로세스의 동작과 역할
11.1 백그라운드 프로세스를 왜 배워야 하는가?
11.2 백그라운드 프로세스와 서버 프로세스의 관계
11.3 DBWR의 동작과 역할
11.4 LGWR의 동작과 역할
11.5 SMON의 동작과 역할
11.6 PMON의 동작과 역할
11.7 LREG의 동작과 역할
11.8 ARCH의 동작과 역할
11.9 그 외의 백그라운드 프로세스
11.10 요약

Chapter 12.오라클 아키텍처와 동작에 관한 Q&A
12.1 지금까지의 복습
12.2 오라클의 동작에 관한 질문
12.3 모니터링/운영에 관한 질문
12.4 (해답과 해설)오라클의 동작에 관한 질문
12.5 (해답과 해설)모니터링/운영에 관한 질문
12.6 요약


- 아키텍처와 동작을 지속적으로 설명하여 머릿속에서 이미지를 떠올릴 수 있도록 한다.
- 가능한 한 오라클 이외의 용어(it 기본 용어)를 사용해서 설명한다.
- 명령어를 설명하는 것은 이 책의 주목적이 아니다.

- 오라클이라고 하더라도 결국 그 실체는 디스크나 네트워크를 사용하는 OS상에서의 애플리케이션에 지나지 않는다.
- 이 책의 구체적인 목표는 '오라클의 기본적인 아키텍처를 이해하는 것'이다.

 # 오라클을 이해하기 위한 필수 키워드
1. 병렬 처리를 가능케 하고 높은 처리량을 실현한다.
2. 응답 시간(response time)을 중시한다.
3. 커밋(COMMIT)한 데이터는 지킨다.

- 어떻게 I/O의 대기 시간을 줄일까?
시퀀셜 액세스
 - 시퀀셜(sequential)은 '순서를 따라서'라는 의미의 '순차'를 뜻하며, 시작점에서부터 마지막까지 중간 부분을 빠트리지 않고 전부 액세스(읽기/쓰기)하는 것을 의미합니다.
 - 메모리에 테이블의 데이터가 없으면 풀 스캔(Full Scan, 테이블의 모든 데이터를 읽어오는 것)할 때 시퀀셜 액세스가 발생합니다.

랜덤 액세스
 - 디스크의 관점에서 생각해보면 랜덤 액세스는 비효율적인 부분이 존재한다.

- 시퀀셜 액세스는 'db file scattered read'라고 표시되며, 랜덤 액세스는 'db file sequential read'라고 표시된다.
  반대로 되어 있는 것이 아닌가라는 생각도 들지만, 표시가 잘못되어 있는 것은 아니다.
  오라클은 블록 단위로 데이터를 읽고 쓰며, 메모리에 배치해둔다.
  시퀀셜 액세스는 '순차로 읽는다'라는 의미로, 여러 블록을 한꺼번에 빠짐없이 읽어온다. 이때 읽어온 여러 블록은 메모리상에 연속되지 않은 형태로 놓인다. 따라서 'scattered'라고 표현한다.
  그에 반해 랜덤 액세스에서 읽어오는 데이터 블록은 한 번에 한 개이며, 메모리 공간에 반드시 연속적으로 놓인다. 따라서 'sequential'이라고 표현한다.
  한번 읽어온 블록을 메모리에 어떻게 배치하는지에 따라 표현하는 방법을 다르게 한 것이다.

 # 1.5 요약
- 디스크가 회전하고 있는 이미지
- 헤드가 움직이는 것과 회전해 오기를 기다리고 있어서 I/O에 시간이 걸리는 이미지
- 인덱스로 인해 해당 데이터에 빠르게 접근할 수 있다(테이블을 맨 앞에서부터 끝까지 풀 스캔하지 않아도 된다)는 이미지

- SSD는 플래시 메모리를 사용한 저장 장치입니다. HDD의 자기 디스크와는 다르게 주소로 표시되는 저장 공간에 데이터를 보존합니다.
  따라서 디스크의 회전 등 물리적인 동작을 필요로 하지 않고, 빠르게 데이터를 보존하고 꺼내올 수가 있습니다. 또한, 디스크에서 필요한 회전 등의 기계적인 구조 역시 필요 없으므로 충격에도 강합니다.

- 오라클을 포함한 DBMS(데이터베이스 관리 시스템)도 기본적인 동작은 '데이터를 짐처럼 맡아서 보관하고, 요구에 따라 데이터를 반환한다'라는 점에서 꽤 비슷합니다.

- 대부분의 시스템에서 애플리케이션은 JDBC(Java DataBase Connectivity)나 ODP.NET(Oracle Data Provider for .NET), Pro*C(오라클에서 사용하는 C언어 프리 컴파일러) 같은 것을 통해 오라클에서 SQL문을 수행합니다.
  SQL*Plus는 대부분 데이터베이스의 관리(테이블이나 인덱스의 생성 및 사람이 수동으로 직접 데이터를 검색하는 작업 등)를 위해서 사용합니다.

- 프로세스는 실행 중인 상태에 있는 프로그램을 의미합니다. 실행 중인 상태이기 때문에 메모리나 자원을 가지고 있습니다. 다르게 표현하자면 실체화(materialization)했다고 할 수 있습니다.
  프로세스를 다르게 비유하자면 프로그램을 따라서 일하는 난쟁이(작은 사람)와 같습니다. 유닉스(UNIX)상에 프로그램이 여러 개 실행되어 있다고 해도 그것들은 각각 다른 사람(프로세스)이므로 CPU가 여러 개 있다면 동시에 처리할 수 있습니다.
  이에 비해 스레드는 프로세스 내에 존재하는 실행 단위를 말합니다. 하나의 프로세스 안에서 병렬로 작업을 처리하고 싶을 때 사용합니다.
  어느 쪽이든 병렬로 처리하기 위한 구조이지만, 가장 다른 점은 부하의 크기와 메모리를 공유하는지의 여부입니다. 프로세스는 각자 독립적으로 수행되어 자원을 독자적으로 사용하므로 부하가 크고, 메모리를 공유하지 않습니다. 스레드는 한 프로세스 안에서 수행되므로 부하가 적지만 스레드끼리 메모리를 공유하므로 주의해서 사용해야 합니다.

- 오라클은 같은 프로세스가 여러 개 작동한 느것이 아닙니다. 실은 다른 역할을 가진 여러 가지 프로세스가 존재하고 있습니다.

- 오라클은 다음의 두 가지 프로세스로 구성되어 있습니다.
  - 서버 프로세스(SQL문을 처리하는 프로세스)
  - 백그라운드 프로세스(주로 서버 프로세스를 지원하는 프로세스)

- 오라클 클라이언트는 서버 프로세스와 통신(대화)합니다. 따라서 서버 프로세스는 일반적인 회사에서 말하는 '고객 담당'에 해당합니다.
  그리고 고객 담당을 지원하는 각종 지원 스태프(백그라운드 프로세스)가 창고 업자인 오라클에도 있습니다.

- 오라클에서 수행하는 주요 처리는 다음과 같습니다.
  1) SQL문의 수신
  2) SQL문의 파싱(어떤 테이블에 어떻게 접근해야 하는지를 생각하는 작업)
  3) 데이터 읽기(디스크에서 읽어온다)
  4) 데이터 기록(디스크에 기록한다)
  5) SQL문의 결과 회신
  6) 로그 기록(데이터의 변경 로그를 디스크에 기록)
  7) 각종 정리(프로세스의 비정상 종료로 인한 아무도 사용하지 않는 LOCK의 해제 등)
  8) 로그 보관(아카이브)

- 포어그라운드 프로세스(foreground process)
서버 프로세스를 말합니다. 백그라운드와 반대의 의미를 가진 서버 프로세스는 이렇게 불리기도 합니다. 단, 이 용어는 현장에서 사용되기보다는 오라클에서 사용하는 도구(툴)들 내에 표시되는 용어로 사용되고 있습니다.

 # 2.6 요약
- 데이터베이스는 모두 공유해서 사용한다
- 애플리케이션이나 SQL*Plus 같은 오라클 클라이언트가 여러 개 존재하고, 여러 개의 SQL문이 오라클에 전달된다
- 오라클 위에서 여러 개의 SQL문이 동시에 동작하고 있다(PC에서의 엑셀과는 다르다)
- 서버 프로세스는 SQL문의 결과를 가능하면 빠르게 회신하기 위한 일을 한다(고객을 최우선으로 영업한다)
- 서버 프로세스를 도와주는 백그라운드 프로세스가 존재한다(지원 스태프)

- 오라클 RAC란?
RAC란 Real Application Clusters의 약자로서, 오라클 클러스터웨어(Clusterware)를 활용한 오라클 데이터베이스의 클러스터 기술을 말합니다. 간단하게 말하면 여러 개의 서버상에 가동된 인스턴스를 하나의 데이터베이스처럼 사용할 수 있습니다. 여러 개의 서버로 구성되어 있지만 데이터의 일관성을 유지하기 위해 스토리지는 함께 사용합니다.
일반적으로 여러 대의 인스턴스로 구성한 것을 RAC 구성, 한 개의 인스턴스로 구성한 것을 싱글 구성이라고 부릅니다.
일반적인 HA(High Availability, 고가용성) 구성과 비교해서 RAC 구성이 가진 특징은 각 서버가 액티브(active)/스탠바이(standby)가 아닌 액티브/액티브 구성이므로 서버의 CPU나 메모리 같은 자원을 100% 활용할 수 있다는 점입니다. 즉, 두 대 이상의 저렴한 서버가 비싼 서버 한 대 보다 강력하게 동작합니다. 그러므로 사용 가능한 자원이라면 모두 사용하는 것이 이득일 것입니다.
그리고 장애와 관련된 가용성 역시 향상됩니다. 한 개의 인스턴스에 장애가 발생하더라도 남은 인스턴스로 작업을 처리할 수 있기 때문에 지속적인 운영이 가능합니다.
또한, RAC를 구성하는 서버를 추가/삭제할 수도 있습니다. 서버를 추가한다는 것은 CPU와 메모리를 추가하는 것에 상응하며, 당연히 가용성도 향상됩니다. 아울러 시스템 요건의 변화에 따라 유연하게 대응할 수 있다는 점도 매력적입니다.
감이 좋으신 독자분께서는 '스토리지를 함께 사용하기 때문에 변경 정보는 디스크에 기록될 때까지 다른 서버에서 확인할 수 없는 것이 아닌가?'라고 생각하실 수도 있습니다. 하지만, RAC는 메모리에 캐시되어 있는 블록을 서버 간에 공유하므로 디스크의 I/O를 기다릴 필요 없이 데이터의 일관성을 유지할 수 있는 구조를 가지고 있습니다.

- 캐시는 가장 간단한 튜닝 항목이자 잘 알려진 기능 중 하나이지만, 아키텍처를 제대로 이해하고 있지 않으면 생각지도 못한 부분에서 '가져오고 싶었던 데이터가 캐시에 존재하지 않아 성능이 좋지 않다'와 같은 결과를 초래합니다.   캐시의 동작을 잘 이해해서 데이터베이스의 성능을 올려줍시다.

- 어느 정도 공유 메모리를 알게 되었으니 설정 방법을 알아보도록 하겠습니다. 오라클의 설정 파일인 spfileXXXX.ora(XXXX에는 데이터베이스를 식별하는 ID가 들어갑니다)에는 버퍼 캐시의 크기를 결정하는 'DB_CACHE_SIZE'라는 파   라미터가 있습니다. [버퍼 캐시의 크기를 설정하는 파라미터 중 'DB_BLOCK_BUFFERS'는 오라클 12.2부터는 권고하지 않습니다.]
  앞에서 설명한 것처럼 버퍼 캐시는 성능과 직결되기 때문에 크기를 정할 때 신중히 결정해야 합니다.
- 공유 메모리의 설정 예(리눅스의 경우)
  # /sbin/sysctl -a | grep shm
  kernel.shmall = 2097152
  kernel.shmmax = 4294967295
  kernel.shmmni - 4096
  => 'shm'으로 시작하는 부분이 공유메모리의 설정

- 버퍼 캐시의 크기와 관련된 최근의 이야기
지금까지 설명했던 것처럼 버퍼 캐시의 설정은 성능에 직결되는 중요한 부분입니다. 그렇기 때문에 독자 여러분께서는 '그럼 대체 어떻게 버퍼 캐시의 크기를 정해야 하는가?'라는 의문이 들 겁니다.
데이터베이스를 새로 설치할 때와 같이 적절한 크기를 알 수 없는 경우에는 임시로 처음 크기를 크게 잡아 놓습니다. 그 후에 대표적인 업무를 실제로 돌려보면서 관련된 통계를 기반으로 조정하는 방법이 있습니다.
그때 도움이 될 수 있는 힌트를 드리면, 버퍼 캐시 크기마다 물리 읽기 수를 예측하는 버퍼 캐시 어드바이저(V$DB_CACHE_ADVICE)나 버퍼 캐시 내에서 요청받은 블록을 꺼내온 빈도를 의미하는 버퍼 캐시 히트율이 있습니다. 버퍼 캐시의 튜닝과 관련된 상세 내용을 알고 싶으신 분은 아래의 매뉴얼을 참고하세요. [참고 : 오라클 공식 문서 'Database Performance Tuning Guide'의 13.Tuning the Database Buffer Cache]
또한, 버퍼 캐시를 아예 설정하지 않는 접근 방법도 있습니다. 부하의 정도에 따라 오라클이 자동으로 조절하도록 설정하는 방법입니다. 공유 메모리(SGA)에는 버퍼 캐시 이외에도 SQL의 파싱 결과를 보관하는 공유 풀과 같은 다른 영역이 존재하며, 각각 설정하게 될 경우 크기를 하나하나 검토해야 합니다. 이런 영역들의 크기를 개별적으로 설정해서 관리하는 것이 아니라 SGA만 크기를 설정해 놓으면 나머지는 오라클이 알아서 관리하는 것을 '자동 공유 메모리 관리(Automatic Shared Memory Management)'라고 부릅니다(PGA 내의 영역을 자동으로 관리하는 '자동 PGA 메모리 관리(AUtomatic PGA Memory Management)'나, SGA와 PGA 간의 비율도 자동으로 조정하는 '자동 메모리 관리(Automatic Memory Management)'라는 기능도 있습니다).
이 기능들을 사용하면 크기를 예측하느라 고생하지 않아도 부하의 정도에 따라 오라클이 알아서 조정해주기 때문에 최근에는 자동으로 설정해놓고 사용하는 곳들도 많아지는 추세입니다. 다만, 저는 자동 공유 메모리를 설정할 때는 DB_CACHE_SIZE를 함께 설정하는 것을 추천합니다. 자동 공유 메모리를 설정한 상태로 DB_CACHE_SIZE를 설정하면 하한값으로서 동작하므로 혹여라도 버퍼 캐시의 영역이 다른 영역에 잡아먹혀서 성능이 나빠지는 상황을 방지할 수 있기 때문입니다.

- '세마포어(semaphore)'란?
세마포어는 OS가 제공하는 자원을 관리하기 위한 장치의 일종으로, 자원의 수에 비해 사용하고자 하는 프로세스의 수가 많을 경우에 순서대로 자원을 사용할 수 있도록 프로세스 제어를 수행합니다. 여러 개의 프로세스가 동작하는 오라클도 프로세스 제어에 세마포어를 사용하고 있습니다.
  # /sbin/sysctl -a | grep sem
  kernel.sem = 250 32000 100 128
  => 'sem'으로 시작하는 설정이 세마포어의 설정
기본적으로 세마포어도 매뉴얼에서 지시하는 대로 설정하면 문제는 없지만, 오라클 이외의 애플리케이션에서 사용할 수도 있으므로 오라클을 기동할 때 세마포어가 부족하다는 의미의 메시지가 나타나면 늘리는 것을 검토해야 합니다. 또한, 아무도 사용하지 않는 세마포어가 OS에 남아있는 경우도 있으므로 정리할 필요가 있습니다. 그럴 때는 DBA가 ipcs 명령어나 ipcrm 명령어를 사용해서 정리하면 됩니다.

- 버퍼 캐시는 자주 사용하는 데이터를 더 빠르게 가져오기 위해 존재합니다. 또한, 버퍼 캐시의 크기는 한정되어 있으므로, 누군가가 어떤 식으로든 관리하고 정리해야 합니다. 캐시에 사용하는 알고리즘 중 일반적으로 알려진 것이 'LRU(Least Recently Used) 알고리즘'입니다.

- 자주 사용하지 않는 데이터를 버퍼 캐시에 둘 필요는 없습니다. 구체적인 예를 들자면, 데이터가 많은 테이블을 풀 스캔한 데이터는 적재해두더라도 사용하는 경우는 별로 없으며, 오히려 풀 스캔한 데이터를 적재해 둠으로써 자주 사용하는 데이터를 캐시에서 쫓아내는 일이 발생하게 됩니다. 따라서 오라클은 큰 테이블이라고 판단하면 버퍼 캐시로 블록(데이터)을 적재하지 않으며, 풀 스캔했을 때의 데이터는 일반적으로 버퍼 캐시에 적재되지 않는다고 생각하세요.

 # 3.10 요약
- 오라클에 같은 성능 테스트를 반복해서 수행하고 있습니다. 첫 번째 테스트가 종료한 후 캐시를 정리하기 위해 오라클을 재기동했더니 두 번째의 테스트에서는 속도가 빨라졌습니다. 왜 그럴까요?
  => 정답은 'OS의 버퍼 캐시에 데이터가 적재되어 있기 때문'입니다. 오라클을 재기동했다 해도 OS는 재기동하지 않았습니다. 즉, OS의 버퍼 캐시에 데이터가 남아 있었다는 의미입니다.
     이전까지는 이상해 보이기만 했던 현상들이 OS나 스토리지, 오라클의 아키텍처나 동작을 공부하다보면 서서히 이해되기 시작하고, 더 나아가서는 다양한 상황에도 잘 대처할 수 있게 됩니다. 여러 번 성능 테스트를 수행하고 결과를 검토할 때 '테스트 결과 중 성능이 안 좋았던 결과는 한 번이었으니 특이사항은 없는 것 같다'라며 해당 결과를 무시하는 엔지니어를 종종 만날 수 있습니다. 만약 아키텍처를 잘 이해하고 'OS의 캐시에 의해 두 번째부터는 빠르게 처리되고 있는 것처럼 보일 뿐'이라는 것을 알았다면 제대로 대처할 수 있지 않을까요?

- '분석(parse, 파스)'이라 부르는 처리 방법의 생성과 생성한 처리 방법을 캐시하는 장소인 '공유 풀(shared pool)'

- 일반적인 프로그래밍 언어와 SQL의 차이는 무엇일까요? 여러 가지가 있을 거라 생각합니다만, SQL은 '처리 방법(절차)'을 기술하지 않는다는 점이 가장 큰 차이라고 말할 수 있습니다. 기본적으로 '데이터가 만족하는 조건이나 관계'를 기술하지만, 오라클은 힌트(hint)라는 기능을 이용해서 오라클의 처리 순서를 어느 정도는 지시할 수 있습니다.
예를 들어, 'SELECT /*+ index(A B) */ FROM A WHERE C = 1'이라는 SQL문은 테이블 A의 B라고 하는 인덱스를 사용해서 처리하도록 지시한 것이 됩니다. 또한, 여러 개의 테이블을 조인하여 검색하는 SQL문에서는 ordered라고 하는 힌트를 사용해서 테이블의 조인 순서를 지시할 수 있습니다.

- 어떤 작업을 할 때 누군가가 처리 방법을 생각하지 않으면 작업을 처리할 수 없습니다. RDBMS에서는 사람이 아니라 '옵티마이저(파서, parser)'라고 불리는 기능이 처리 방법을 생각해줍니다. 옵티마이저(파서)가 SQL문을 분석하고 '실행 계획(plan, 플랜)'이라고 하는 처리 방법을 생성해줍니다.

- 오라클은 '규칙 기반(rule base)'과 '비용 기반(cost base)'이라는 알고리즘을 가지고 있습니다. 단, 오라클 10g부터 규칙 기반을 지원하지 않습니다.

- 비용 기반이라는 것을 간략히 이야기해보자면, '처리 시간이나 I/O 횟수가 가장 작다고 생각되는 처리 방법이 최상이다'라는 알고리즘입니다. 오라클에서는 처리 시간이나 I/O 횟수를 예측하기 위해서 '비용(cost)'이라고 불리는 수치를 이용합니다. 비용을 단순하게 이야기하면, '처리에 필요하다고 생각되는 시간 또는 자원 사용량'입니다. 즉, 인간이라면 작업을 가장 빠르게 처리할 수 있다고 생각되는 방법을 선택하는 것과 마찬가지입니다.

- 실제로 비용은 '통계 정보'라 불리는 기초 수치를 기반으로 계산됩니다. 통계 정보는 '이 테이블에는 데이터가 몇 로우(행)가 존재하고 있으며, 데이터의 양은 이 정도다. 컬럼의 데이터 최댓값과 최솟값은 이런 값이다. 해당 테이블의 인덱스는…'과 같은 테이블이나 인덱스에 관한 기초 수치를 말합니다.

- 오라클에서는 통계 정보를 '애널라이즈(Analyze)'라고 불리는 작업을 통해 얻습니다.

- 풀차다, 행걸리다
현장에서는 문서로 접할 수 없는 용어가 사용되기도 합니다. 그런 용어들을 주변 사람들에게 물어 보기란 쉽지가 않습니다. 그래서 여기서는 현장에서 사용되는 용어 중, 시스템의 상태에 관련된 몇 가지 용어를 소개하겠습니다.
  => 풀차다
'가득 차다'라는 의미입니다. 한계까지 도달했을 때 '풀 찼다'라는 말을 사용합니다. 예를 들어 '테이블스페이스가 풀차서 장애가 발생했어'처럼 이야기하며, 여기서 '풀'은 영문 FULL의 발음을 그대로 표기한 것입니다.
  => 행걸리다
프로그램 수행 중 멈춰서 더 이상 진행이 되지 않는 상황(hang)을 의미합니다. 예를 들어 '세션이 행에 걸려서 멈춰 있다'와 같이 성능 이슈나 여러가지 장애로 인해 작업이 진행되지 않고 멈춰 있는 상태를 의미합니다.

- 간혹 DBMS가 좋지 않은 실행 계획을 선택하는 이유(원인)는 무엇일까요? 대표적으로는 '선택할 수 있는 실행 계획의 수가 많다는 점'과 이런 실행 계획들이 '어디까지나 예측에 지나지 않는다는 점' 때문입니다.

- 어댑티브 쿼리 최적화의 장점과 단점
오라클의 주 기능이라고 부를 수 있는 옵티마이저는 버전이 올라갈수록 발전해왔습니다. 오라클 12c부터는 어댑티브 쿼리 최적화(Adaptive Query Optimization)라는 옵티마이저 통계를 보정하는 기능이 추가되었고, 덕분에 사람이 수고하지 않더라도 좀 더 성능이 좋은 실행 계획을 선택할 수 있게 되었습니다. 그러나 시스템에 따라서는 사용 방법에 주의가 필요합니다.
오라클에서는 실행 계획을 결정할 때 사전에 수집해둔 통계 정보를 참고해서 처리 대상 테이블의 추세를 파악합니다. 이 추세를 기반으로 가장 처리 비용이 적다고 예측되는 액세스 패스, 조인 순서, 조인 방법 등을 판단합니다.
주목해야 되는 부분은 '통계 정보는 사전에 수집된다'라는 점입니다. 이 부분은 SQL문을 분석할 때 발생하는 부하를 줄이기 위한 것이지만, SQL문을 실행할 때 통계 정보와의 괴리가 발생했을 때는 최적의 실행 계획이 선택되지 않을 가능성이 있습니다. 이를 방지하기 위해서는 DBA가 적절한 수집 시점이나 빈도, 수준으로 통계 정보를 수집하는 작업을 수행해야 합니다.
오라클 12c에서 추가된 어댑티브 쿼리 최적화 기능으로 인해 SQL문을 실행할 때 추가로 통계 정보를 동적으로 수집한 후 최종적으로 실행 계획을 선택할 수 있게 되었습니다. 이로 인해 사전에 수집한 통계 정보의 부족한 부분을 보정하고 좀 더 좋은 실행 계획을 실시간으로 선택하는 것이 가능해졌습니다.
단, 통계 정보의 동적 수집이 동작하는 만큼 분석하는 시간이 길어지게 된다는 점에 주의해야 합니다. 실제로 '오라클 12c에서 SQL문 속도가 느려졌다'라는 사례도 있습니다. OLTP같이 실행 시간이 짧은 SQL문이 다수 실행되는 시스템에서는 동적 통계 수집으로 인한 분석 시간이 길어지는 경향이 있습니다. 이때는 정적 통계 수집을 검토하는 것이 좋습니다.
또한, 시스템에 따라서는 옵티마이저 통계를 정기적으로 수집하지 않거나 통계에 Lock을 걸어 '옵티마이저에 의한 실행 계획의 변동'을 제어하는 경우도 있습니다. 또한, 초기화 파라미터를 설정하여 실행 계획이 변경되는 것을 방지할 수도 있습니다.
좀 더 상세한 내용은 다음의 매뉴얼 문서를 참고하세요. [참고 : 오라클 공식 매뉴얼 'SQL Tuning Guide'의 4.4 About Adaptive Query Optimization]

- 공유 풀은 실행 계획을 재사용하여 분석 작업을 줄이기 위한 존재라고 봐도 좋습니다. 따라서 공유 풀을 잘 활용하면 CPU 자원의 절약으로도 이어집니다.

- 공유 풀도 프로세스 간에 공유되어야 하므로 버퍼 캐시와 마찬가지로 공유 메모리에 있습니다. 공유 메모리의 많은 부분이 버퍼 캐시로 사용되고, 거기서 남은 일부가 공유 풀로 사용됩니다. 더욱이 공유 풀은 라이브러리 캐시(여기에 실행 계획이 존재합니다)나 딕셔너리 캐시 같은 영역으로 나누어집니다.

- 오라클은 해시 알고리즘을 사용해서 SQL문마다 ID를 생성합니다. 좀 더 정확히 설명하면, SQL문을 문자열(데이터)로 해시 함수에 입력하고 함수에서 출력된 해시 값을 SQL문의 ID로 사용합니다. 해시 함수에서 대문자와 소문자는 다른 문자이므로 쿼리의 대문자와 소문자가 다르면 받는 해시 값도 달라집니다. 사람이 보면 같은 SQL문으로 보이지만, 오라클에서 보면 전혀 다른 SQL문이 됩니다.
  => Select id, cust_name, tel_no from cust where id = 1;
  => select id, cust_name, tel_no from cust where id = 1;
첫 번째 글자가 'S'냐 's'냐의 차이만 있을 뿐 의미상으론 다르지 않음. 사람이 보면 같은 SQL문이지만, 오라클은 다른 SQL문이라고 판단함

이와는 다르게 검색 조건의 값이 다른 SQL문에 바인드 변수를 사용하면 같은 SQL문으로 판단합니다.

- 분석(파스)에는 하드 파스(hard parse)와 소프트 파스(soft parse)가 있습니다. 하드 파스는 지금까지 설명해왔던 분석을 말하는데, 공유 풀에 실행 계획이 없으므로 실행 계획을 생성하는 경우를 의미합니다. 소프트 파스는 해시 값을 요청한 결과, 공유 풀에 캐시되어 있는 실행 계획을 찾았기 때문에 재사용하는 경우를 의미합니다.

- 오라클의 성능 진단 도구
스태츠팩(Statspack)은 오라클 표준 성능 진단 도구입니다. 스태츠팩은 오라클 8i 이상 버전에서 설치할 수 있으며, 성능 정보를 수집합니다. 예를 들어, 자원을 대량으로 소비하는 SQL문을 특정하거나 캐시 히트율을 확인하는 것으로 병목 현상을 구분할 수 있습니다.
또한, 오라클 10g 이상부터는 스ㅐ츠팩을 진화시킨 AWR(Automatic Workload Repository)이라는 기능을 사용할 수 있습니다. AWR은 설치할 필요가 없으며, 스태츠팩으로는 수집할 수 없는 통계 정보와 관련된 분석도 수행됩니다. 다만, AWR을 사용하기 위해서는 Diagnostics Pack 라이선스가 필요합니다.
좀 더 상세한 내용은 다음의 문서를 참고하세요.
[참고 <<Database Performance Tuning Guide>>의 6 Gathering Database Statistics]

 # 4.7 요약
- SQL문에는 처리 방법이 적혀 있지 않기 때문에 오라클이 처리 방법(실행 계획)을 생성할 필요가 있다는 점
- 실행 계획의 좋고 나쁨에 따라 성능이 크게 변한다는 점
- 실행 계획을 생성하기 위해서는 많은 양의 CPU를 사용하기 때문에 공유 풀(라이브러리 캐시)에 실행 계획을 캐시해두고 재활용한다는 점

- 통계 정보는 언제 수집해야 하나요?
오라클이 비용을 계산할 때 사용하는 기본 정보가 통계 정보입니다. 적절한 실행 계획은 적절한 통계 정보가 있기 때문에 도출해낼 수 있습니다. 반대로 말하면 실제와 다른 통계 정보를 기반으로 도출되는 실행 계획은 성능에 문제를 일으키는 원인이 될 수 있습니다.
그러면 적절한 통계 정보를 수집하기 위해 고려해야 하는 것은 무엇일까요? 답은 바로 '시점'입니다.
통계 정보를 단순히 정기적으로 수집하는 것만으로는 충분하지 않습니다. 가장 중요한 점은 시스템의 특성을 고려한 '적절한 시점'에 수집하는 것입니다.
예를 들어, 통계 정보를 자동 통계 수집(기본 설정으로는 평일 22:00부터 다음날 2:00까지 사이)으로 수집하는 상황에 매일 밤 21시에 수행되는 배치가 있는 경우를 생각해보겠습니다. 그리고 배치 처리로 인해, 테이블의 데이터양이 낮시간 대비 1/1000 정도로 줄어든다고 가정하겠습니다.
데이터양이 줄어든 시점에 수집된 통계 정보를 기반으로 만들어진 실행 계획을 데이터양이 많은 낮시간에 사용한다면 어떤 상황이 발생할까요?
적절한 실행 계획은 데이터의 양에 따라 다릅니다. 이 경우에는 본래 사용해야 할 인덱스 스캔(INDEX SCAN)이 아니라 풀 스캔을 선택해버리는 문제가 발생할 수 있으며, 치명적인 성능 문제로 이어질 가능성이 높습니다.
이런 예처럼 일정 주기로 데이터양의 증감이 반복되는 상황에서 데이터양이 많은 낮시간대의 처리를 대비하기 위해서는 일반적으로 데이터양이 많은 시점에 통계 정보를 수집하면 적절한 실행 계획이 만들어질 것이라 예측할 수 있습니다. 대신에 데이터양이 적은 밤시간에 수행되는 배치 처리는 효율이 떨어질 수 있습니다.
따라서 데이터베이스 관리자는 통계 정보의 수집 시점, 통계 정보의 고정, 힌트 등을 조합하여 의도한 실행 계획이 도출될 수 있도록 운영해야 합니다.

- 4장의 지식은 현장에서 어떻게 활용되는가?
현장에서 튜닝할 때는 분석이나 실행 계획에 관한 지식을 사용하므로 관련 내용을 이번 칼럼에서 간략하게 소개하겠습니다. 다만 여기서 소개하는 내용은 개요 정도이므로 자세하게 알고 싶으신 분은 해당 매뉴얼을 참고하세요.
  
  => 실행 계획이 나쁘고 SQL문의 성능이 좋지 않을 때
우선은 비용 계산의 기초 정보가 되는 통계 정보가 제대로 수집되고 있는지 데이터베이스 관리자에게 문의해봅시다. 수집하고 있지 않다면 dbms_stats 패키지(또는 analyze 명령어)를 사용해서 최신 통계 정보를 수집하면 좀 더 좋은 실행 계획이 만들어질 가능성이 높아집니다. 단, 관리자의 운영 정책으로 통계 정보를 수집하지 않는 경우도 있으므로 관리자와 협의없이 수집해서는 안 됩니다. 통계 정보를 제대로 수집해도 만들어진 실행 계획이 적합치 않을 때는 옵티마이저의 판단이 좋지 않다는 의미이므로, 힌트나 플랜 스태빌리티(Plan Stability)라고 불리는 기능을 사용해서 오라클에 지시를 내립니다.

  => 하드 파스가 많으며, 분석에 사용하는 CPU 양이 많을 때
바인드 변수를 사용할 수 있도록 SQL문을 변경할 수 있는지를 검토합니다. 하지만 실제 프로젝트에서는 애플리케이션을 수정할 수 없는 경우도 많습니다. 그럴 때는 CURSOR_SHARING이라고 하는 초기화 파라미터를 설정함으로써 바인드 변수를 적용한 것과 거의 같은 효과를 얻을 수 있습니다. 단, 이 기능을 사용하기 전에 PSR(Patch Set Release, 오라클 제품에 대한 패치 파일)을 적용하여 혹시 모를 버그 등에 대응할 것을 권고합니다.

  => 크기에 관한 튜닝
공유 풀의 크기에 관한 튜닝은 아쉽게도 그리 간단하지 않습니다. 왜냐하면 free memory(미사용 메모리)가 없어질 때까지는 '사용 빈도가 적은 데이터'인데도 버리려고 하지 않기 때문입니다. 다시 말해 'free memory가 적으니까 크기를 늘리지 않으면 안 되겠군'이라고 말할 수 없다는 것입니다. 바인드 변수를 사용하여 소프트 파스로 처리되도록 SQL문을 작성했음에도, SQL문이 캐시에서 자주 밀려나 하드 파싱이 일어나는 경우가 있습니다. 그럴 때는 공유 풀의 크기를 늘려주면 효과가 있는 경우도 있습니다.

- 오라클을 관리하기 위한 단위로 인스턴스(instance)라는 용어를 사용하고 있습니다. 인스턴스라고 하면 객체지향 언어를 경험해보신 분들은 '엔터티(entity)'를 떠올리시겠지만, 오라클에서의 인스턴스는 백그라운드 프로세스 + 공유 메모리를 의미합니다.

- NOMOUNT 상태 : 인스턴스가 기동한 상태
- OPEN 상태 : 인스턴스가 기동되고 데이터베이스가 오픈된 상태 = 데이터베이스가 기동한 상태

- 여러 버전의 오라클을 설치하기 위해서는?
오라클의 프로그램은 ORACLE_HOME이라고 불리는 경로 아래의 bin 안에 들어 있습니다. 즉, 이 말은 여러 버전의 오라클을 설치하기 위해서는 ORACLE_HOME을 분리할 필요가 있다는 의미입니다. 실제로 테스트 등을 위해서 여러 버전의 오라클을 하나의 서버에 설치하는 경우가 많습니다.

- 오라클의 기동에 관한 요점을 정리해보면 다음과 같습니다.
  => 우선은 초기화 파라미터를 읽어서 백그라운드 프로세스를 생성하고 공유 메모리(버퍼 캐시나 공유 풀)를 확보합니다. 이것을 NOMOUNT라고 부릅니다.
  => 초기화 파라미터 파일에 입력된 컨트롤 파일의 위치를 확인하고 컨트롤 파일을 열어 데이터베이스를 구성하는 각종 파일의 위치를 확인합니다. 이것을 MOUNT라고 부릅니다. 다만, 위치를 알아내는 것뿐이므로 이 시점에서는 파일이 없어도 에러가 발생하지 않습니다.
  => 데이터 파일이나 REDO 로그 파일에 문제가 없다면(오라클이 내부적으로 사용하는 데이터들의 앞뒤가 맞지 않는 상황이 아니라면) 데이터 파일을 읽고 기록할 수 있는 상태로 전환합니다. 즉, SQL을 실행할 수 있는 상태가 됩니다. 이것을 OPEN이라고 부릅니다.

- PFILE과 SPFILE
초기화 파라미터에는 'PFILE'과 'SPFILE'의 두 종류가 존재하며, 인스턴스는 기본적으로 SPFILE을 사용합니다.
  => PFILE(파라미터 파일)
    텍스트 형식으로 저장된 파라미터 파일입니다. 텍스트 에디터를 통한 파라미터 수동 변경이 가능하지만, 변경을 바녕하기 위해서는 인스턴스를 재기동할 필요가 있습니다. PFILE은 데이터베이스 생성할 때나 장애 발생 시에 사용합니다.
  => SPFILE(서버 파라미터 파일)
    오라클 9i 이후에 추가된 바이너리 형식의 파라미터 파일입니다. 텍스트 에디터를 사용한 파라미터 변경은 불가능하며, 파라미터 변경을 하기 위해서는 SQL문(ALTER SYSTEM문)을 사용합니다. 파라미터를 변경할 때는 반영할 범위(현재의 인스턴스만인지, 재기동 후인지, 둘 다인지)를 지정할 수 있습니다. SPFILE은 PFILE을 사용해 수동으로 생성되거나, 데이터베이스를 생성할 때 사용하는 DBCA에 의해 자동으로 생성됩니다.

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 





