COS PRO 대비 개인정리용

 # 풀이순서
- 같은 유형의 문제 먼저 풀이하기
- main함수 부터 읽는다.

 # 아스키 코드표
- 0(48) -> A(65) -> a(97)

 # Part2. 자료형, 연산자
- 문자열 -> 정수 변환 ; Integer.valueOf(str); - Integer 래퍼 객체를 반환
- 문자열 -> 정수 변환 : Integer.parseInt(str); - int 타입의 원시데이터를 반환

 # Part4. 배열
- Arrays.toString() 메서드 : 반복문을 사용하지 않고 배열의 값을 출력하고자 한다면 Arrays 클래스의 toString() 메서드를 사용하면 된다. toString() 인자로는 배열명을 넣어주면 된다.
- 배열 복사하기 -> arraycopy() 메서드 : System.arraycopy(원본배열명, 복사 시작할 위치, 복사배열명, 붙여넣을 시작 위치, 길이);

 # Part8. 알고리즘
- Integer 최소값, 최대값 : Integer.MIN_VALUE;, Integer.MAX_VALUE;
- 랜덤 정수(0~9) : (int)(Math.random()*10);
- Arrays.sort(배열명); // import java.util.Arrays;
- 내림차순이거나 또는 원하는대로 정렬의 조건을 설정해서 하고자 할 때에는 기본형(Primitive Type)의 배열에는 적용이 안된다. -> 따라서, 래퍼 클래스로 만들어서 적용해야 한다. ex) Integer[] arrays
- Arrays.sort(배열명, Collections.reverseOrder()); // import java.util.Collections

 # Part9. 자격증(COS PRO 2급)
- 빈도 수 패턴
  -> 초기값이 0인 빈 정수형 배열 ar을 만들고, ar[target[i]]++;
- while 반복문과 continue
  -> 탈출 빠져나오는 조건식이 반복문 맨 끝과 continue 전에 필요하다.
- 최대값/최소값
  -> int max나 min 지정 후 if(max < ar[i]) max=ar[i];
- 배열에서 가장 큰 값인 최대값을 반복문 사용없이
  -> 정렬(sort) 함수 이용
  -> import java.util.Arrays;
  -> ar[0]과 ar[ar.length-1]이 최소, 최대값

 # Part10. 컬렉션, 패키지
- 컬렉션 프레임워크 : Collection, Map
- Collection : List, Set
- List 계열 구현 클래스 : ArrayList, LinkedList, Vector, Stack
  -> 인덱스가 있다.
  -> 저장 순서가 유지된다.
  -> 데이터 중복이 허용
- Set 계열 구현 클래스 : HashSet, SortedSet, TreeSet
  -> 데이터 중복이 허용안됨
- 컬렉션 프레임워크 내에는 다양한 컬렉션들이 있는데 요소(원소)를 읽어올 때 Iterator 인터페이스로 표준화하고 있다.
  -> hasNext() : boolean반환
  -> next() : Object(제네릭)반환
  -> remove() : void
- Collection 인터페이스가 iterator() 메서드를 정의하고 있고, Collection을 상속받는 List, Set 인터페이스로 구현한 객체를 통해 iterator() 메서드 사용

 # String 클래스의 주요 메소드
- charAt(인덱스 값) : 문자열에서 해당 인덱스 위치에 있는 문자 리턴
- length()         : 문자열의 길이 리턴
- equals("문자열")  : 문자열과 인수로 받은 문자열이 같은 지 여부 확인
- valueOf(값)       : 인수로 받은 값을 문자열로 변환하여 리턴
- toUpperCase()     : 문자열을 모두 대문자로 변환하여 리턴
- toLowerCase()     : 문자열을 모두 소문자로 변환하여 리턴
- isEmpty()         : 문자열의 길이가 0인 경우에 true를 리턴
- split()           : String -> String[]
- toCharArray()     : String -> char[]

 # Arrays 클래스의 주요 메소드
- sort(배열명)     : 전달받은 배열을 오름차순으로 정렬
- toString(배열명) : 전달받은 배열의 항목 전체를 한 줄의 문자열로 변환하여 리턴
- copyOf(배열명)   : 전달받은 배열에서 해당 길이를 갖는 새 배열로 복사하여 리턴

 # Math 클래스의 주요 메소드
- random()      : 0.0 이상 1.0 미만의 임의의 실수 값을 리턴
- abs(값)       : 전달된 값의 절대값을 리턴
- max(값1, 값2) : 값1과 값2 중 더 큰 값을 리턴
- min(값1, 값2) : 값1과 값2 중 더 작은 값을 리턴
- round(값)     : 전달된 값의 소수 첫째 자리에서 반올림한 값을 리턴
- pow(값1, 값2) : 값1의 값2승(값2=2이면 제곱)

 # 최대값 구하기(최소값 구하기)
- 최대값의 초기값으로 배열의 첫 번째 항목 혹은 배열이 갖지 않는 아주 작은 값을 지정
- 배열 항목을 차례대로 가져와서 현재 배열 항목 값이 현재의 최대값보다 크면 최대값을 현재 배열 항목 값으로 교체

 # 주이전 수에 있는 각 자리 숫자 추출하기
- 135 : 일의 자리 숫자 : 5                 <-- 135 % 10 = 5
        십의 자리 숫자 : 3 <-- 135/10 = 13 <-- 13 % 10 = 3
        백의 자리 숫자 : 1 <-- 13/10 = 1   <-- 1 % 10 = 1
        천의 자리 숫자 : 0 <-- 1/10 = 0    <-- 나눈 몫 = 0, 추출 작업 종료

 # 배열의 앞뒤 원소 2개씩 비교할때
- for(int i=0; i<arr.length-1; i++) -> arr[i]와 arr[i+1] 비교
- for(int i=1; i<arr.length; i++)   -> arr[i-1]와 arr[i] 비교

 # 득표수 등 counter 배열 생성
- int[] counter = new int[N+1]

 # 등수 rank 배열 생성
- int[] rank = new rank[N] 이후 1로 초기화

 # 6글자 돌아가며 추가 : answer += String.charAt(i%6);

 # 전위 연산자 vs 후위 연산자
- 전위 연산자
  - 변수 앞에 붙은 증감연산자에 의한 계산을 먼저 실행한 후 해당 변수에 대한 명령 실행
- 후위 연산자
  - 해당 변수에 대한 명령을 먼저 실행한 후에 변수 뒤에 붙은 증감연산자에 의한 계산을 수행

 # 알파벳 별 점수 부여
- answer += card.charAt(i) - 'a' + 1; // a와의 차이
 # 2차원 배열에서 개별 항목의 위치
- dy = {-1, 1, 0, 0} : 상하좌우 항목들을 가져오기 위한 행 인덱스 증감값
- dx = {0, 0, -1, 1} : 상하좌우 항목들을 가져오기 위한 열 인덱스 증감값

 # int to String, String to int
- int to String : Integer.toString(int)
- String to int : Integer.parseInt(String)

 # 주어진 수 거꾸로 뒤집기
- for(int i = 0; i < digit; i++) {
    int temp = number % 10;
    number = number / 10;
    ret = ret * 10 + temp;
  }

 # 최대공약수
- for(int i=min; i>=1; i--) {
    if(num1%i==0 && num2%i==0) {
        answer = i;
        break;
    }
  }

 # 최소공배수
- for(int i=1; i<=max; i++) {
    if((min*i)%max==0) {
        answer = min*i;
        break;
    }
  }

- for(int i=max; i<=min*max; i++) {
    if(i%min==0 && i%max==0) {
        answer = i;
        break;
    }
  }

 
 # WIRE
- ArrayList<Integer> list = new ArrayList<Integer>();
  -> list.add();
  -> list.size()
  -> list.get(i);
  -> Collections.sort(list);

 # Comparator와 문자열 비교함수 compareTo();
Arrays.sort(answer, new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        if(o1.charAt(1) > o2.charAt(1)) {
            return 1;
        } else if(o1.charAt(1) == o2.charAt(1)) {
            if(o1.compareTo(o2) > 0) {
                return 1;
            }
        }
        return -1;
    }
});

 # Comparator
ArrayList<String> key = new ArrayList<String>(tmp.keySet());
Collections.sort(key, new Comparator<String>() {

    @Override
    public int compare(String o1, String o2) {
        if(tmp.get(o1) < tmp.get(o2)) {
            return 1;
        } else if(tmp.get(o1) == tmp.get(o2)) {
            if(o1.compareTo(o2) > 0) {
                return 1;
            }
        }
        return -1;
    }
});



