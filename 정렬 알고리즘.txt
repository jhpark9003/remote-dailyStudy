동빈나 정렬 알고리즘
 
 # 0. 정렬 알고리즘
- 정렬(Sorting)이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말합니다.
- 일반적으로 문제 상황에 따라서 적절한 ㅈ어렬 알고리즘이 공식처럼 사용됩니다.
- 7, 5, 9, 0, 3, 1, 6, 2, 4, 8
- 여러 개의 데이터(카드)를 어떻게 정렬할 수 있을까요?

 # 1. 선택 정렬
- 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복합니다.

public class Main {
	public static void main(String[] args) {
		int n = 10;
		int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

		for(int i = 0; i < n; i++) {
			int min_index = i; // 가장 작은 원소의 인덱스
			for(int j = i+1; j < n; j++) {
				if(arr[min_index] > arr[j]) {
					min_index = j;
				}
			}
			// 스와프
			int temp = arr[i];
			arr[i] = arr[min_index];
			arr[min_index] = temp;
		}
		for(int i = 0; i < n; i++) {
			System.out.print(arr[i] + " ");
		}
	}
}


 # 2. 삽입 정렬
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.
- 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작합니다.

public class Main {
	public static void main(String[] args) {
		int n = 10;
		int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

		for(int i = 1; i < n; i++) {
			//인덱스 i부터 1까지 감소하며 반복하는 문법
			for(int j = i; j > 0; j--) {
				//한 칸씩 왼쪽으로 이동
				if(arr[j] < arr[j-1]) {
					//스와프(Swap)
					int temp = arr[j];
					arr[j] = arr[j-1];
					arr[j-1] = temp;
				}
				// 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
				else {
					break;
				}
			}
		}
		for(int i = 0; i < n; i++) {
			System.out.print(arr[i] + " ");
		}
	}
}


 # 3. 퀵 정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법입니다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.
- 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정합니다.

public class Main {

	public static void quickSort(int[] arr, int start, int end) {
		if(start >= end) return; // 원소가 1개인 경우 종료
		int pivot = start; // 피벗은 첫 번째 원소
		int left = start + 1;
		int right = end;
		while(left <= right) {
			//피벗보다 큰 데이터를 찾을 때까지 반복
			while(left <= end && arr[left] <= arr[pivot]) left++;
			//피벗보다 작은 데이터를 찾을 때까지 반복
			while(right > start && arr[right] >= arr[pivot]) right--;
			//엇갈렸다면 작은 데이터와 피벗을 교체
			if(left > right) {
				int temp = arr[pivot];
				arr[pivot] = arr[right];
				arr[right] = temp;
			}
			//엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
			else {
				int temp = arr[left];
				arr[left] = arr[right];
				arr[right] = temp;
			}
		}
		//분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
		quickSort(arr, start, right-1);
		quickSort(arr, right +1, end);
	}

	public static void main(String[] args) {
		int n = 10;
		int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

		quickSort(arr, 0, n-1);
		for(int i = 0; i < n; i++) {
			System.out.print(arr[i] + " ");
		}
	}
}


 # 4. 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘입니다.
  - 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능합니다.

public class Main {
	public static final int MAX_VALUE = 9;

	public static void main(String[] args) {
		int n = 15;
		//모든 원소의 값이 0보다 크거나 같다고 가정
		int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};
		//모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)
		int[] cnt = new int[MAX_VALUE+1];

		for(int i = 0; i < n; i++) {
			cnt[arr[i]] += 1; //각 데이터에 해당하는 인덱스의 값 증가
		}
		for(int i = 0; i <= MAX_VALUE; i++) { //배열에 기록된 정렬 정보 확인
			for(int j = 0; j < cnt[i]; j++) {
				System.out.print(i + " "); //띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력
			}
		}
	}
}
