### ITGO [HD]예제로 공부하는 Java (자바) 100 문제풀이 ###


 # Part1. 환경설정, 변수
- JAVA_HOME : jdk의 위치
- Path : javac가 위치한 위치. JAVA_HOME의 bin폴더

cd $(CURRENT_DIRECTORY)
javac $(FILE_NAME)
java $(NAME_PART)

- 자바 언어[컴파일 언어] : 자바 코드 작성 -> 자바 코드 컴파일(Compile) -> 자바 코드 실행(Run)
  -> 확장자 : Test.java -> Test.class
cf) 파이썬 언어[인터프리터 언어] : 파이썬 코드 작성 -> 파이썬 코드 실행(Run)
  -> 확장자 : Test.py

- class명과 파일명이 같아야 한다.
- 접근제한자 : public, private, protected, default
  -> 클래스나 메서드에 접근할 수 있는 범위를 지정 : 접근제한자, 접근제어자
  -> private > protected > public
- 클래스선언 : class
  -> 객체를 생성하는 틀, 프레임, 공장, 템플릿
- 클래스이름 : 카멜케이스(단어와 단어 사이의 구분 - 대문자)
- 메서드이름 : 메서드란? 함수. 어떤 특정한 동작이나 작업, 행위 등을 수행하는 것.
- 메인메서드 : main() - 만약 다르게 작성하면 기본 메서드를 찾을 수 없다라고 에러 발생
  -> 기본 메서드(main) 작성하라고 함.
  -> 자바 프로그램이 실행되면 제일 먼저 메인 메서드를 찾아서 실행
  -> 길게 작성된 소스에서 그 프로그램의 시작이 어딘지 알 수 없으면 안되므로 시작점을 알려주는 용도
  -> entry point - main()
- 파라미터 : 메서드(함수) 호출시 하나 or 둘 이상의 파라미터 값을 넣어서 호출할 수 있음
  -> 그러한 인수(파라미터)들의 값을 저장할 변수(바구니)들을 명시
  -> String : 문자열, [] : 배열, args : argument(논의, 논쟁, 언쟁, 말다툼, 주장; 인수, 독립 변수)
  -> args는 하나의 변수명일 뿐이므로 임의의 이름을 지정해도 무방.
- 반환타입 : return type : 반환할 값이 있나? 없나? - 없으면 void(빈 공간, 공허함, empty)
  -> 이 메서드(함수)는 호출하면 결과로써 특별히 반환되는 값은 없이 수행되는 메서드
- static으로 선언된 함수(메서드)나 변수는 자바 버추얼 머신에서 인스턴스 객체의 생성 없이 호출을 할 수 있다. 쉽게 말해서, 객체 생성없이 해당 함수(메서드)를 호출해서 사용할 수 있다.
- 자바 프로그램을 실행하면 static으로 지정된 메서드를 찾아서 먼저 메모리에 할당시킨다. static으로 지정된 메서드가 여러개인 경우에는 객체를 생성하는 것과 상관없이 모두 메모리에 할당시킨다. 그런 후에, "main"으로 이름이 만들어진 메서드가 있는지를 찾아서 그 메서드를 가장 먼저 시작점의 메서드로써 호출을 하게 되는 것이다.

- 변수란 무엇인가? 바구니다. 데이터를 저장하는 메모리 공간이다.
- 변수 선언이란 무엇인가? 변수를 사용하기 위해서는 먼저 변수의 타입에 맞는 선언을 해줘야 한다.
  -> 정수형의 변수를 사용하고자 한다면 -> 먼저 정수형 타입의 자료형을 선언해주고 사용해야 한다. -> 데이터타입(자료형)에 대해서는 뒤에..
- 변수의 용도? 저장. 어떤 연산을 수행할 때 값들을 저장해놓아야 하는데 그때 변수(바구니)를 활용한다.

 # Part2. 자료형, 연산자
- 크게 봤을 때. 기본형 타입, 참조형 타입
- 기본형 타입(Primitive Data Type) : 8개
  -> 정수형 : byte(1byte), short(2), int(4), long(8)
  -> 실수형 : float(4), double(8)
  -> 문자형 : char(2byte) : 문자 한 개. 참고로, 문자열을 다루는 타입은 없다.
  -> 부울형(논리형 : 참 or 거짓) : boolean(1byte) - true, false
- 참조형 타입(Reference Data Type) : 위 기본형에 속하지 않는 데이터형들.
  -> 대표적인 것들 : 클래스(class), 배열(array), 인터페이스(interface), 문자열(String/immutable)
  -> 참조형 변수의 특징 : 데이터가 저장된 메모리의 주소 값을 저장하는 변수이다.

- print(), println(), printf()
- %d(정수), %f(소수점 형식), %c(문자), %s(문자열), %b(부울), %n(줄바꿈), %e(지수), %o(8진수), %x(16진수)

- 정수 -> 문자열 변환 : String stra = String.valueOf(a);
- 자릿수 구하기. String str = "123";, str.length();
- 문자열 -> 정수 변환 ; Integer.valueOf(str); - Integer 래퍼 객체를 반환
- 문자열 -> 정수 변환 : Integer.parseInt(str); - int 타입의 원시데이터를 반환

 # Part3. 조건문, 반복문
- switch 조건문 변수 조건은 정수형이어야 한다. byte, short, int. 그러나 long은 안된다. char은 된다.
  -> break, default 빼먹지 않도록 주의한다.
- 삼항연산자 -> 조건 ? 참일 때 : 거짓일 때;

 # Part4. 배열
- 배열명 자체를 찍어서 출력 -> 주소(참조) 값 -> I : 정수형 배열, D : 실수형 배열을 각각 의미함
- arr.length
- Arrays.toString() 메서드 : 반복문을 사용하지 않고 배열의 값을 출력하고자 한다면 Arrays 클래스의 toString() 메서드를 사용하면 된다. toString() 인자로는 배열명을 넣어주면 된다.
- 배열 복사하기 -> arraycopy() 메서드 : System.arraycopy(원본배열명, 복사 시작할 위치, 복사배열명, 붙여넣을 시작 위치, 길이);
- int, double 배열의 값 설정을 해주지 않으면 기본값 0으로 초기화. String 배열은 null로 초기화 된다.
- charAt() 메서드 : 해당 인덱스에 있는 값을 반환 -> 단어를 char 배열에 한글자씩 저장할 수 있음
  -> System.out.println(arr[0].charAt(2));
- 배열의 길이는 arr.length로 쓰고, 문자열의 길이는 str.length()로 쓴다.

 # Part5. 함수
- str.toUpperCase() : 대문자로 변환 메서드
- str.toLowerCase() : 소문자로 변환 메서드

- Call by value : 값에 의한 호출. 값에 의해서 메서드를 호출.
  -> cf. Call by reference

 # Part6. OOP1
- 클래스란 객체(또는 인스턴스)를 생성하는 하나의 공장(=틀, 프레임, 템플릿, 판형 등등..)이다.
- 객체의 특징 : 속성(attribute), 객체의 동작 : 메서드(method)
- String.format("%,d",fm.price); : fm.price의 값을 천단위로 콤마를 찍는다.
- Integer.parseInt(str) : 문자열 -> 숫자로 변환
- Integer.parseInt(str, 8) : 두 번째 인자 값으로 진수를 지정. 8진수의 str이 10진수로 표현된다.

- 하나의 파일에 2개 이상의 클래스를 작성할 수 있다.
- 3개의 클래스가 있다면 자바 파일명이 될 수 있는 것은 public 키워드가 붙은 클래스이다.
- 하나의 파일에 있는 3개의 클래스에 모두 public 키워드를 붙일 수 있다.(X. 거짓.)
- 한 파일내 3개 이상의 클래스에 모두 public 키워드를 안붙일 수 있다.
- 한 파일내 3개 이상의 클래스에 모두 public 키워드가 없다면 클래스중 어느 것이라도 파일명이 될 수 있다.
- 자바 파일에 클래스가 한 개 있다면 클래스명이 곧 파일명이 되어야 한다.

- 생성자(Constructor) : 생성자는 new 키워드로 클래스의 객체(또는 인스턴스)가 생성될 때 제일 먼저 자동적으로 호출되는 특별한 메서드이다. 따라서, 객체의 초기값을 설정하는 등의 용도로 많이 사용된다.
- 생성자명은 클래스명과 동일하게 만든다. 생성자는 리턴되는 반환값이 없다. 객체가 생성될 때 제일 먼저 호출만 된다.
- 생성자는 오버로딩이 가능하다. 생성자는 default 생성자란게 있다.

- 상속(Inheritance) : 부모 클래스가 가지고 있는 속성(변수)들과 동작/기능(메서드)들을 그대로 물려받아 새로운 클래스를 만드는 것. 상속을 활용하면 물려받은 것들은 그대로 쓰면 되고, 거기에 덧붙여 새로운 것만 만들면 되므로 그만큼 노력과 시간이 세이브된다.
  -> 원본 클래스를 부모 클래스(Parent class), 슈퍼 클래스(Super class)라고 한다.
  -> 상속받는 클래스는 자식 클래스(Child class), 또는 서브/하위 클래스(Sub class)라고 부른다.
  -> 또다른 표현으로는 기초/기반 클래스(Base class), 파생 클래스(Derived class)라고도 부른다.
  -> extends 키워드 사용
  -> 부모 클래스의 멤버 필드, 메서드는 상속이 가능하나 생성자는 상속이 안된다.
  -> 부모 클래스의 접근 제한자 private인 경우에는 아무리 자식 클래스가 상속을 받았다 하더라도 접근 불가능.

 # Part7. OOP2
- 추상 클래스 : 구체적인 내용은 작성하지 않고 공통적인 특징을 추상적으로 선언 -> 리턴값 조차도 없이 메서드 명만 선언.
  -> 추상 클래스는 구체적인 내용이 없기 때문에 객체를 생성할 수 없다. 상속을 받아서 사용한다.
  -> 즉, 추상(부모) 클래스를 상속받은 자식 클래스에서 해당 메서드를 오버라이딩하여 재정의한 후 사용한다.
  -> 추상(부모) 클래스는 다른(자식) 클래스들의 공통적인 특징을 변수나 메서드로 정의만 해놓는 것을 말한다.
  -> abstract를 앞에 붙이고 클래스 안에 추상 메서드를 포함하고 있다는 것을 제외하면 사실 일반 클래스와 별반 차이가 없다. Field, Constructor, Method(일반 메서드)도 포함할 수 있다.
  -> 메서드 선언만 있고 구체적인 내용은 없으므로 객체를 생성할 수 없다. 따라서, 부모 클래스로서의 역할은 하지만, 구체적인 사용은 상속받은 자식 클래스에서 재정의(오버라이딩)하여 사용해야 한다. -> 강제성
  -> 추상 클래스에서 선언만 해놓음으로써 이후 새로운(자식) 클래스들이 이를 상속 받아 구현하므로 새로운 클래스를 작성할 때 하나의 틀이 된다.
  -> 왜 쓰지? -> 우선 강제하기 위함이다. 부모(추상) 클래스가 선언해놓은 메서드를 상속받은 자식 클래스들이 이름 그대로 재정의해서 구현하라고 강제하는 것이다. 상속받은 자식 클래스 입장에서는 자칫 상속만 받고 재정의해서 사용을 안할 수도 있기 때문이다. 즉, 일반 메서드로 구현하면 누군가는 해당 메서드를 구현 안 할 수도 있다. 무조건 상속받은 자식 클래스 입장에서는 추상 메서드를 재정의(오버라이딩)해서 구현하도록 강제하기 위함이다.
  -> 꼭 재정의(override) 해야만 하는가? -> 일단 그렇다. 자식 클래스는 일단 무조건 부모(추상) 클래스로부터 상속받은 추상 메서드는 오버라이딩해서 재정의해야 한다. 추상 메서드를 포함하고 있다면 곧 추상 클래스여야 한다.
  -> 만약 재정의하고 싶지 않다면? 자식 클래스에서 상속받은 추상 메서드를 구현하지 않는다면 자식 클래스도 abstract를 붙여서 추상으로 만들어준다.
  -> 결론 : 부모(추상) 클래스에서 구현을 하지 않는 이유는 해당 메서드의 구현이 상속받는 클래스에 따라서 달라질 수 있기 때문에 선언만 해둔 것이다. 이러한 추상 클래스는 여러 명의 개발자가 작업할 때 코드의 확장과 분업을 효율적으로 처리할 수 있게 해준다. 분업화된 시스템에서 공통의 프로젝트를 진행할 때 많이 사용되어지는 중요한 문법이다.
- 인터페이스 : 결합부, 접속기. 사용자간 또는 컴퓨터간 통신이 가능하도록 해주는 디바이스나 프로그램.
  -> 상호간 통신을 위해서는 ‘규격’이 중요하다. 이러한 ‘규격’을 인터페이스라 할 수 있고, 인터페이스는 하나의 ‘표준화’를 제공하는 것이라 할 수 있다. 일종의 ‘설계도’ 개념
  -> 인터페이스를 이용하면 메서드의 추상적인 ‘선언’과 그 메서드들을 구체적인 ‘구현’ 부분을 분리시킬 수 있다. 매우 큰 장점이다. 하청을 주는 대기업(갑)은 하청업체(을)에 인터페이스만 제공. 각 하청업체(을)들이 이를 준수하여(=상속 받아) 개발. 분업화된 시스템을 구축하여 ‘갑’과 ‘을’이 독립적으로 프로젝트 개발을 해나갈 수 있다.
  -> 상속을 받는 extends 키워드와 구현을 하는 implements 키워드가 동시에 쓰일 때 extends 키워드가 항상 먼저 쓰인다.
  -> 변수는 가질 수 없으나 상수는 가질 수 있다. public static final. 즉, 생략이 가능하다. 따라서 그냥 ‘타입 상수명’만 적어도 public static final이 자동적으로 생성된다.
  -> 인터페이스 내 모든 메서드는 public abstract 이어야 한다. 즉, 생략이 가능하다.
- 추상 클래스 vs 인터페이스 : 인터페이스가 추상화 정도가 더 높다.(더 엄격하다.) 따라서 일반 메서드 멤버 필드(변수)를 가질 수 없다.
- 자바에서의 인터페이스 문법? 표준화 및 규격을 인터페이스로 제공. 따라서 어떤 클래스가 해당 인터페이스를 사용(상속)한다면 인터페이스에 선언되어져 있는 메서드를 구현해야 한다. 인터페이스는 class 키워드를 사용하지 않고 interface 키워드를 사용한다. class -> extends, interface -> implements
- 추상 클래스와 같이 메서드의 구체적인 내용은 기술되어져 있지 않으므로 인터페이스를 상속받는 클래스에서 재정의(오버라이딩)하여 사용해야 한다.
- 상속 vs 구현 : 클래스와 인터페이스. 이 둘의 가장 큰 차이점 중 하나는 ‘상속’이다.
  -> 자바에서 클래스는 ‘단일 상속’만 가능하지만, 인터페이스는 ‘다중 상속’이 가능하다.
  -> 인터페이스에서는 extends 표현을 쓰지않고 ‘구현’의 의미를 강조하는 implements 키워드를 사용하여 다중 상속을 구현한다.

- 다형성이란 다양한 형태 또는 특성을 가진다는 의미. 자바와 같은 객체 지향 언어에서의 의미는 부모 클래스를 상속받은 자식 클래스의 인스턴스가 부모의 객체로도 사용되고, 뿐만 아니라, 자식 클래스의 객체로도 사용될 수 있는 다양한 상황을 의미한다.
- 부모 타입으로 객체를 생성하면 부모의 자원만을 쓸 수 있다. 단, 오버라이딩 한 메서드가 있다면 오버라이딩 한 자식의 메서드로 실행된다.
  -> 자식의 메서드를 바로 호출하고 싶다면? -> 형변환 사용
- 자식 클래스에서 오버라이딩 된 부모 클래스의 원본 메서드를 호출하고 싶다면?? -> super 사용

- 매개변수의 다형성
  -> 프로그래밍 언어에서 함수나 메서드를 호출할 대는 그에 맞는 적절한 파라미터를 보내줘야 한다.
  -> 실제 메서드의 API를 보면 public void println( Object x ) 로 되어 있기에 어떤 객체 타입이 전달되더라도 에러없이 출력이 되는 것이다.
  -> 결론적으로, Object는 가장 최상위 조상이므로 어떤 객체를 보내도 그보다 상위 타입이 된다.

 # Part8. 알고리즘
- Integer 최소값, 최대값 : Integer.MIN_VALUE;, Integer.MAX_VALUE;
- 랜덤 정수(0~9) : (int)(Math.random()*10);
- Arrays.sort(배열명); // import java.util.Arrays;
- 내림차순이거나 또는 원하는대로 정렬의 조건을 설정해서 하고자 할 때에는 기본형(Primitive Type)의 배열에는 적용이 안된다. -> 따라서, 래퍼 클래스로 만들어서 적용해야 한다. ex) Integer[] arrays
- Arrays.sort(배열명, Collections.reverseOrder()); // import java.util.Collections

 # Part9. 자격증(COS PRO 2급)
- 빈도 수 패턴
  -> 초기값이 0인 빈 정수형 배열 ar을 만들고, ar[target[i]]++;
- while 반복문과 continue
  -> 탈출 빠져나오는 조건식이 반복문 맨 끝과 continue 전에 필요하다.
- 최대값/최소값
  -> int max나 min 지정 후 if(max < ar[i]) max=ar[i];




 # Part10. 컬렉션, 패키지



 # 씨스꿀 강의
- 워크 스페이스란? 이클립스에서 생성한 프로젝트가 기본적으로 저장되는 폴더를 의미함
- .metadata 폴더
  -> 자동적으로 생성이 되며, 이클립스 실행 시 메타데이터를 저장함
  -> 이 폴더를 삭제하면, 이클립스 재 실행시 초기 상태로 됨

- 변수(variable) - 하나의 값을 저장하기 위한 공간
- 상수(constant) - 한 번만 값을 저장할 수 있는 공간
- 리터럴(literal) - 그 자체로 값을 의미하는 것
int score = 100;
score = 200;
char ch = 'A';
String str = "abc";
final int MAX = 100;
에서 변수 : score, ch, str / 상수 : 100 / 리터럴 : 100, 200, A, abc, 100

- 비트 연산자 : 피연산자를 비트단위로 연산한다. 단, 실수형(float, double)은 제외된다.
  -> OR( | ) 연산자 : 피연산자 중 어느 한 쪽이 1이면 1이다.
  -> AND( & ) 연산자 : 피연산자 중 둘 다 1이면 1이다.
  -> XOR( ^ ) 연산자(exclusive or) ; 피연산자가 서로 다를 때, 1이다. - 배타적 논리합이라고도 한다.
- 이항 연산자의 특징
  -> byte + byte -> int + int로 바뀌어 int로 return된다.
  -> byte c = (byte)b1 + b2; // Err. b2가 int로 되어 int 반환. 연산자의 우선 순위 : 단항 > 이항
  -> byte c = (byte)(b1 + b2); : 명시적 형변환, 강제 형변환, Unboxing(객체 단)

- Math.random() : 특정 범위의 정수 난수 얻기
  -> 0.0 <= Math.random() < 1.0

- 문자열 입력받을 땐 sc.nextLine();
- 정수 입력받을 땐 sc.nextInt();